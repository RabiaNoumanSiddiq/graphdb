{"version":3,"sources":["webpack:///./src/js/angular/rest/connectors.rest.service.js","webpack:///./src/js/angular/externalsync/controllers.js","webpack:///./src/js/angular/core/directives/queryeditor/query-editor.directive.js"],"names":["angular","module","factory","ConnectorsRestService","$inject","CONNECTORS_ENDPOINT","$http","getConnectors","get","initConnector","prefix","hasConnector","checkConnector","data","post","headers","jsonToFormData","str","Object","keys","forEach","key","push","encodeURIComponent","join","mapCreateValuesToUiValues","values","options","i","length","option","__type","__name","j","__childOptions","child","k","valueK","hasOwnProperty","isDefined","__defaultValue","optionEl","isUndefined","map","_","value","toJson","_evaluateSparqlQuery","http","repository","query","buildNamePrefix","substring","createConnectorQuery","name","fields","reportError","fcopy","sortObject","obj","newObject","each","childOption","copy","arrayMap","reduce","acc","Error","fromJson","e","__label","message","removeEmptyValues","Array","isArray","filter","item","trim","finalString","replace","ConnectorsCtrl","$scope","$repositories","$modal","toastr","ModalService","$q","RDF4JRepositoriesRestService","resetProgress","repair","beingBuiltConnector","percentDone","status","processedEntities","estimatedEntities","indexedEntities","entitiesPerSecond","actionName","waitOnRepairStartOnce","eta","inline","iri","openProgressModal","$","extend","doneCallback","modalInstance","dismiss","open","templateUrl","controller","size","backdrop","scope","executeCreate","connector","errorCallback","modal","addStatements","getActiveRepository","update","then","res","existing","success","err","error","getError","finally","loader","controllers","definitions","getLoaderMessage","timeSeconds","Date","now","loaderStartTime","timeHuman","getHumanReadableSeconds","progressMessage","extraMessage","setLoader","isRunning","canWriteActiveRepo","connectors","all","connectorIris","createStatusQueryForAny","evaluateSparqlQuery","results","bindings","statusObject","JSON","parse","console","parseFirstBuildingResult","d","split","catch","getOptions","isEmpty","isObject","toPrettyJson","$watch","getActiveLocation","copyConnector","newValues","resolve","result","skipConversion","newConnector","inst","type","openSimpleModal","title","warning","delete","isExternal","indexOf","force","namePrefix","deleteConnectorQuery","viewQuery","DeleteConnectorCtrl","$modalInstance","ok","close","cancel","ExtendNewConnectorCtrl","toQuery","label","addField","index","optionName","newField","defaultValues","splice","addOption","array","deleteOption","addMapOption","deleteMapOption","form","$valid","CreateConnectorCtrl","$controller","this","CreateProgressCtrl","$interval","initProgress","statusIri","createStatusQueryForIri","progressInterval","getFirstStatusFromResult","toFixed","etaSeconds","$on","input","Math","ceil","queryEditorDirective","$timeout","$location","SparqlRestService","$jwtAuth","LocalStorageAdapter","LSKeys","callbackOnChange","restrict","link","element","attrs","nostorage","notabs","notoolbar","notoolbarSaved","notoolbarCopy","notoolbarInference","notoolbarSameAs","nostatus","norun","runButtonName","nocount","callback","saveQueryAction","click","runQueryAction","runQuery","explainQueryAction","goToNextTabAction","tabs","currentQuery","id","isTabChangeOk","idx","findTabIndexByID","selectTab","goToPreviousTabAction","requestedTab","first","tab","changePagination","explainRequested","window","editor","fromTextArea","document","getElementById","persistent","indentUnit","createShareLink","cursorHeight","sparql","showQueryButton","acceptHeaderGraph","acceptHeaderSelect","extraKeys","addNewTab","toastBuildIndex","allowHtml","toastError","on","css","clearTimeout","changesTimeout","hasError","queryValid","setTimeout","toggleClass","attr","getValue","queryType","getQueryType","hide","afterCopy","event","target","removeClass","addClass","blur","onbeforeunload","set","TABS_STATE","saveTab","originalExecuteQuery","executeQuery","originalGetUrlArguments","getUrlArguments","createCustomError","statusText","responseText","connectorProgressModal","yasr","drawButtons","yasqe","buttons","config","qType","currentTabConfig","pageSize","offset","page","cm","resultsContainer","empty","currentTrackAlias","performance","countTimeouted","getQueryMode","endpoint","args","inference","sameAs","customUpdateMessage","thisTabConfig","thisTabId","executedQueryTab","handlers","countCallback","dataOrJqXhr","textStatus","jqXhrOrErrorString","setResultsCount","allResultsCount","allCount","allResultsCountExact","outputType","output","queryStartTime","getTime","setQueryLimit","isActiveRepoOntopType","getValueWithoutComments","doExecute","getRepositorySize","repoSize","parseInt","command","hasSupport","timeFinished","timeTook","customError","connectorName","pluginName","getException","setNewTabState","progressScope","$new","originalGetAjaxConfig","getAjaxConfig","getResponseHeader","contentType","response","executedQueryTabIdx","queryResultState","yasrData","resultsCount","sizeDelta","errorMessage","warningMessage","toBoolean","v","loadQueryIntoExistingOrNewTab","infer","tabId","getExistingTabId","onHandler","search","execute","highlightNextTabChange","body","addTabWithQueryIfNeeded","savedQueryName","owner","getSavedQuery","TABS_STATE_CURRENT_ID","updateRepositoryAndSecurity","getNamespaces","signal","getAuthToken","callbackOrConfig","copyToClipboardQuery","openCopyToClipboardModal","url","location","protocol","host","pathname","param","createQueryURL","copyToClipboardResult","resultURI","goToVisual","paramsToParse","path","addKnownPrefixes","getUsedPrefixes","persistency","getQueryResultsAsFormat","downloadFormat","$wbDownload","val","auth","localStorage","getItem","submit","complete","setNewTabStateForThis","setYasrResponse","updateResultsCallback","repoSizeDiff","undefined","Number","responseJSON","max","hasClass","resetResults","setResponse","namespaces","mouseup","container","is","has","showSampleQueries","toggleSampleQueries","find","focus","drawQueryEditor","directive"],"mappings":"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","file":"27.5089831daf42bf903e6c.bundle.js","sourcesContent":["angular\n    .module('graphdb.framework.rest.connectors.service', [])\n    .factory('ConnectorsRestService', ConnectorsRestService);\n\nConnectorsRestService.$inject = ['$http'];\n\nconst CONNECTORS_ENDPOINT = 'rest/connectors';\n\nfunction ConnectorsRestService($http) {\n\n    return {\n        getConnectors,\n        initConnector,\n        hasConnector,\n        checkConnector\n    };\n\n    function getConnectors() {\n        return $http.get(CONNECTORS_ENDPOINT);\n    }\n\n    function initConnector(prefix) {\n        return $http.get(`${CONNECTORS_ENDPOINT}/options?prefix=${prefix}`);\n    }\n\n    function hasConnector(prefix) {\n        return $http.get(`${CONNECTORS_ENDPOINT}/existing?prefix=${prefix}`);\n    }\n\n    function checkConnector(data) {\n        return $http.post(`${CONNECTORS_ENDPOINT}/check`, data, {\n            headers: {\n                'Content-Type': 'text/plain'\n            }\n        });\n    }\n}\n","import 'angular/rest/rdf4j.repositories.rest.service';\nimport 'angular/rest/connectors.rest.service';\n\nconst modules = [\n    'graphdb.framework.rest.rdf4j.repositories.service',\n    'graphdb.framework.rest.connectors.service'\n];\n\nangular\n    .module('graphdb.framework.externalsync.controllers', modules)\n    .controller('ConnectorsCtrl', ConnectorsCtrl)\n    .controller('ExtendNewConnectorCtrl', ExtendNewConnectorCtrl)\n    .controller('CreateConnectorCtrl', CreateConnectorCtrl)\n    .controller('CreateProgressCtrl', CreateProgressCtrl)\n    .controller('DeleteConnectorCtrl', DeleteConnectorCtrl)\n    .filter('ceil', ceil);\n\nfunction jsonToFormData(data) {\n    const str = [];\n    Object.keys(data).forEach(function (key) {\n        str.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));\n    });\n    return str.join('&');\n}\n\nfunction toArrayMap(map) {\n    return _.map(map, function (value, key) {\n        return {key: key, value: value};\n    });\n}\n\nfunction fromArrayMap(arrayMap) {\n    return _.reduce(arrayMap, function (acc, value) {\n        if (value.key === '' && value.value === '') {\n            // empty pair, skip it\n        } else if (value.key === '') {\n            throw new Error('Key may not be empty with value \"' + value.value + '\"');\n        } else if (acc.hasOwnProperty(value.key)) {\n            throw new Error('Duplicate key ' + value.key);\n        } else {\n            acc[value.key] = value.value;\n        }\n        return acc;\n    }, {});\n}\n\nfunction mapCreateValuesToUiValues(values, options) {\n    for (let i = 0; i < options.length; i++) {\n        const option = options[i];\n        if (option.__type === 'StringArray') {\n            if (!values[option.__name]) {\n                values[option.__name] = [''];\n            }\n        } else if (option.__type === 'OptionArray') {\n            if (!values[option.__name]) { // values has no entry for this option\n                values[option.__name] = [];\n                const optionEl = {};\n                for (let j = 0; j < option.__childOptions.length; j++) {\n                    const child = option.__childOptions[j];\n                    if (child.__type === 'StringArray') {\n                        optionEl[child.__name] = [''];\n                    } else {\n                        optionEl[child.__name] = (!angular.isUndefined(child.__defaultValue) ? child.__defaultValue : '');\n                    }\n                }\n                values[option.__name].push(optionEl);\n            } else { // values already has en entry for this option\n                // Copies the default value for Boolean child options if no explicit value is set\n                for (let j = 0; j < option.__childOptions.length; j++) {\n                    const child = option.__childOptions[j];\n                    if (child.__type === 'Boolean') {\n                        for (let k = 0; k < values[option.__name].length; k++) {\n                            const valueK = values[option.__name][k];\n                            if (!valueK.hasOwnProperty([child.__name]) && angular.isDefined(child.__defaultValue)) {\n                                valueK[child.__name] = child.__defaultValue;\n                            }\n                        }\n                    }\n                }\n            }\n        } else if (option.__type === 'Map') {\n            if (!values[option.__name]) {\n                values[option.__name] = [];\n            } else {\n                values[option.__name] = toArrayMap(values[option.__name]);\n            }\n        } else if (option.__type === 'JsonString') {\n            if (values[option.__name]) {\n                values[option.__name] = angular.toJson(values[option.__name], 2);\n            }\n        } else {\n            if (angular.isUndefined(values[option.__name])) {\n                values[option.__name] = (!angular.isUndefined(option.__defaultValue) ? option.__defaultValue : '');\n            }\n        }\n    }\n\n    return values;\n}\n\nfunction _evaluateSparqlQuery(http, repository, query) {\n    return http.post('repositories/' + repository, jsonToFormData({query: query}),\n        {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Accept': 'application/sparql-results+json',\n                'X-GraphDB-Local-Consistency': 'updating'\n            }\n        });\n}\n\nfunction buildNamePrefix(prefix) {\n    return prefix.substring(0, prefix.length - 1) + '/instance#';\n}\n\nfunction createConnectorQuery(name, prefix, fields, options, reportError) {\n    // Returns a copy of the parameter obj sorted according to the order in options\n    function sortObject(obj, options) {\n        const newObject = {};\n        _.each(options, function (option) {\n            if (angular.isDefined(obj[option.__name])) {\n                if (option.__type === 'OptionArray') {\n                    newObject[option.__name] = [];\n                    _.each(obj[option.__name], function (childOption) {\n                        newObject[option.__name].push(sortObject(childOption, option.__childOptions));\n                    });\n                } else {\n                    newObject[option.__name] = angular.copy(obj[option.__name]);\n                }\n            }\n        });\n        return newObject;\n    }\n\n    const fcopy = sortObject(fields, options);\n\n    for (let i = 0; i < options.length; i++) {\n        try {\n            if (options[i].__type === 'Map') {\n                fcopy[options[i].__name] = fromArrayMap(fcopy[options[i].__name]);\n            } else if (options[i].__type === 'JsonString') {\n                fcopy[options[i].__name] = angular.fromJson(fcopy[options[i].__name]);\n            }\n        } catch (e) {\n            reportError(options[i].__label, e.message);\n            return null;\n        }\n    }\n\n    removeEmptyValues(fcopy);\n    //escapeValues(fields);\n    let finalString = '';\n    finalString += 'PREFIX :<' + prefix + '>\\n';\n    const namePrefix = buildNamePrefix(prefix);\n    finalString += 'PREFIX inst:<' + namePrefix + '>\\n';\n    finalString += 'INSERT DATA {\\n';\n    finalString += \"\\tinst:\" + name + \" :createConnector '''\\n\"; // eslint-disable-line quotes\n    finalString += angular.toJson(fcopy, 2);\n    finalString += \"\\n''' .\\n}\\n\"; // eslint-disable-line quotes\n    finalString = finalString.replace(/\\\\/g, '\\\\\\\\\\\\');\n    return finalString;\n}\n\nfunction createStatusQueryForIri(iri) {\n    const statusIri = iri.replace(/\\/instance#.+$/, '#connectorStatus');\n    let finalString = '';\n    finalString += 'SELECT ?status {\\n';\n    finalString += '\\t<' + iri + '> <' + statusIri + '> ?status';\n    finalString += '\\n}';\n    return finalString;\n}\n\nfunction createStatusQueryForAny(connectors) {\n    const connectorIris = _.map(connectors,\n        function (k) {\n            return '<' + k.value + 'connectorStatus' + '>';\n        }).join('|');\n\n    if (connectorIris) {\n        return 'SELECT ?connector ?status { ?connector ' + connectorIris + ' ?status }';\n    }\n\n    return null;\n}\n\nfunction repairConnectorQuery(name, prefix) {\n    const namePrefix = buildNamePrefix(prefix);\n    return 'PREFIX prefix:<' + prefix + '>\\n' +\n        'INSERT DATA {\\n' +\n        '\\t<' + namePrefix + name + '> prefix:repairConnector \"\"\\n' +\n        '}';\n}\n\nfunction deleteConnectorQuery(name, prefix, force) {\n    const namePrefix = prefix.substring(0, prefix.length - 1) + \"/instance#\";\n    return 'PREFIX prefix:<' + prefix + '>\\n' +\n        'INSERT DATA {\\n' +\n        '\\t<' + namePrefix + name + '> prefix:dropConnector \"' + (force ? \"force\" : \"\") + '\"\\n' +\n        '}';\n}\n\nfunction removeEmptyValues(data) {\n    // remove empty values from array\n    if (Array.isArray(data)) {\n        data = _.filter(data, function (item) {\n            return item !== null && (!item.trim || item.trim() !== '');\n        });\n    }\n    // remove empty values from object values\n    Object.keys(data).forEach(function (key) {\n        if ((data[key] === '' || data[key] == null) && data[key] !== false) {\n            delete data[key];\n        } else if (typeof data[key] === 'object') {\n            data[key] = removeEmptyValues(data[key]);\n        }\n    });\n    return data;\n}\n\nfunction parseFirstBuildingResult(results) {\n    if (results.bindings) {\n        for (let i = 0; i < results.bindings.length; i++) {\n            try {\n                const statusObject = JSON.parse(results.bindings[i].status.value);\n                if (statusObject.status === 'BUILDING') {\n                    return {\n                        connector: results.bindings[i].connector.value,\n                        status: statusObject\n                    };\n                }\n            } catch (e) {\n                console.error(e); // eslint-disable-line no-console\n            }\n        }\n    }\n\n    return {};\n}\n\nConnectorsCtrl.$inject = ['$scope', '$http', '$repositories', '$modal', 'toastr', 'ModalService', '$q', 'RDF4JRepositoriesRestService', 'ConnectorsRestService'];\n\nfunction ConnectorsCtrl($scope, $http, $repositories, $modal, toastr, ModalService, $q, RDF4JRepositoriesRestService, ConnectorsRestService) {\n    $scope.loader = false;\n\n    $scope.controllers = [];\n\n    $scope.existing = {};\n\n    $scope.definitions = {};\n\n    $scope.getLoaderMessage = function () {\n        const timeSeconds = (Date.now() - $scope.loaderStartTime) / 1000;\n        const timeHuman = $scope.getHumanReadableSeconds(timeSeconds);\n        let message = '';\n        if ($scope.progressMessage) {\n            message = $scope.progressMessage + '... ' + timeHuman;\n        } else {\n            message = 'Running operation...' + timeHuman;\n        }\n        if ($scope.extraMessage && timeSeconds > 10) {\n            message += '\\n' + $scope.extraMessage;\n        }\n\n        return message;\n    };\n\n    $scope.setLoader = function (isRunning, progressMessage, extraMessage) {\n        if (isRunning) {\n            $scope.loader = true;\n            $scope.loaderStartTime = Date.now();\n            $scope.progressMessage = progressMessage;\n            $scope.extraMessage = extraMessage;\n        } else {\n            $scope.loader = false;\n            $scope.progressMessage = '';\n            $scope.extraMessage = '';\n        }\n    };\n\n    $scope.initConnector = function (connector) {\n        return ConnectorsRestService.initConnector(encodeURIComponent(connector.value))\n            .then(function (res) {\n                $scope.definitions[connector.key] = res.data;\n\n                return ConnectorsRestService.hasConnector(encodeURIComponent(connector.value))\n                    .then(function (res) {\n                        $scope.existing[connector.key] = res.data;\n\n                    });\n            });\n    };\n\n    $scope.getConnectors = function () {\n        if (!$scope.canWriteActiveRepo()) {\n            return;\n        }\n\n        $scope.setLoader(true, 'Fetching connectors', 'Normally this is a fast operation but it may take longer if a bigger repository needs to be initialised first.');\n\n        ConnectorsRestService.getConnectors()\n            .then(function (res) {\n                $scope.connectors = Object.keys(res.data).map(function (key) {\n                    return {key: key, value: res.data[key]};\n                });\n\n                $q.all(_.map($scope.connectors, function (connector) {\n                    return $scope.initConnector(connector);\n                })).finally(function () {\n                    resetProgress();\n\n                    const query = createStatusQueryForAny($scope.connectors);\n\n                    if (query) {\n                        evaluateSparqlQuery(query)\n                            .then(function (res) {\n                                const status = parseFirstBuildingResult(res.data.results);\n                                if (status.connector) {\n                                    // has a building connector, open progress indicator\n                                    const d = status.connector.split(/#/);\n                                    d[0] = d[0].replace(/\\/instance$/, '#');\n                                    showProgress(d[0], d[1]);\n                                }\n                            })\n                            .finally(function () {\n                                $scope.setLoader(false);\n                            });\n                    } else {\n                        $scope.setLoader(false);\n                    }\n                });\n            }).catch(function (e) {\n                $scope.setLoader(false);\n                toastr.error(getError(e), 'Could not get connectors');\n            });\n\n        $scope.existing = {};\n    };\n\n    $scope.getOptions = function (connector) {\n        return $scope.definitions[connector.key];\n    };\n\n    $scope.isEmpty = function (value) {\n        return angular.isObject(value) && Object.keys(value).length === 0;\n    };\n\n    $scope.toPrettyJson = function (value) {\n        return angular.toJson(value, 2);\n    };\n\n    $scope.$watch(function () {\n        return $repositories.getActiveRepository();\n    }, $scope.getConnectors);\n\n    $scope.$watch(function () {\n        return $repositories.getActiveLocation();\n    }, $scope.getConnectors);\n\n    function evaluateSparqlQuery(query) {\n        return _evaluateSparqlQuery($http, $repositories.getActiveRepository(), query);\n    }\n\n    function resetProgress(repair) {\n        $scope.beingBuiltConnector = {\n            percentDone: 0,\n            status: {\n                processedEntities: 0,\n                estimatedEntities: 0,\n                indexedEntities: 0,\n                entitiesPerSecond: 0\n            },\n            actionName: repair ? 'Repairing' : 'Creating',\n            waitOnRepairStartOnce: !!repair,\n            eta: '-',\n            inline: false,\n            iri: null\n        };\n    }\n\n    function openProgressModal(prefix, name, repair) {\n        resetProgress(repair);\n\n        $.extend($scope.beingBuiltConnector, {\n            iri: buildNamePrefix(prefix) + name,\n            name: name,\n            inline: false,\n            doneCallback: function () {\n                $scope.beingBuiltConnector.modalInstance.dismiss('cancel');\n            }\n        });\n\n        $scope.beingBuiltConnector.modalInstance = $modal.open({\n            templateUrl: 'pages/connectorProgress.html',\n            controller: 'CreateProgressCtrl',\n            size: 'lg',\n            backdrop: 'static',\n            scope: $scope\n        });\n\n        return $scope.beingBuiltConnector.modalInstance;\n    }\n\n    function showProgress(prefix, name) {\n        resetProgress();\n\n        $.extend($scope.beingBuiltConnector, {\n            iri: buildNamePrefix(prefix) + name,\n            name: name,\n            inline: true,\n            doneCallback: function () {\n                $scope.beingBuiltConnector.inline = false;\n            }\n        });\n    }\n\n    function executeCreate(connector, obj, errorCallback) {\n        const modal = openProgressModal(connector.value, obj.name, false);\n        RDF4JRepositoriesRestService.addStatements($repositories.getActiveRepository(), jsonToFormData({update: obj.query}))\n            .then(function () {\n                ConnectorsRestService.getConnectors().then(function () {\n                    ConnectorsRestService.hasConnector(encodeURIComponent(connector.value)).then(function (res) {\n                        $scope.existing[connector.key] = res.data;\n                    });\n                });\n                toastr.success('Created connector ' + obj.name);\n            }, function (err) {\n                toastr.error(getError(err));\n                errorCallback();\n            }).finally(function () {\n                modal.dismiss('cancel');\n            });\n    }\n\n    $scope.copyConnector = function (connector, values) {\n        let newValues;\n        if (!angular.isUndefined(values)) {\n            newValues = angular.copy(values);\n            newValues.name = newValues.name + '-copy';\n        }\n        const modal = $modal.open({\n            templateUrl: 'pages/createConnector.html',\n            controller: 'CreateConnectorCtrl',\n            size: 'lg',\n            backdrop: 'static',\n            resolve: {\n                connector: function () {\n                    return connector;\n                },\n                values: function () {\n                    return angular.isUndefined(newValues) ? {name: '', values: {}} : newValues;\n                },\n                options: function () {\n                    return $scope.getOptions(connector);\n                }\n            }\n        });\n\n        modal.result.then(function (obj) {\n            executeCreate(connector, obj, function () {\n                obj.skipConversion = true;\n                $scope.newConnector(connector, obj);\n            });\n        });\n    };\n\n    $scope.newConnector = function (connector, values) {\n        const modal = $modal.open({\n            templateUrl: 'pages/createConnector.html',\n            controller: 'CreateConnectorCtrl',\n            size: 'lg',\n            backdrop: 'static',\n            resolve: {\n                connector: function () {\n                    return connector;\n                },\n                values: function () {\n                    return angular.isUndefined(values) ? {name: '', values: {}} : values;\n                },\n                options: function () {\n                    return $scope.getOptions(connector);\n                }\n            }\n        });\n\n        modal.result.then(function (obj) {\n            executeCreate(connector, obj, function () {\n                obj.skipConversion = true;\n                $scope.newConnector(connector, obj);\n            });\n        });\n    };\n\n    $scope.repair = function (inst, type) {\n        ModalService.openSimpleModal({\n            title: 'Confirm repair',\n            message: 'Are you sure you want to repair this connector?<br>Note that repair means delete + recreate with the same settings.',\n            warning: true\n        }).result\n            .then(function () {\n                const modal = openProgressModal(type.value, inst.name, true);\n\n                const query = repairConnectorQuery(inst.name, type.value);\n\n                RDF4JRepositoriesRestService.addStatements($repositories.getActiveRepository(), jsonToFormData({update: query}))\n                    .then(function () {\n                        ConnectorsRestService.getConnectors().then(function () {\n                            ConnectorsRestService.hasConnector(encodeURIComponent(type.value)).then(function (res) {\n                                $scope.existing[type.key] = res.data;\n                            });\n                        });\n                        toastr.success('Repaired connector ' + inst.name);\n                    }, function (err) {\n                        toastr.error(getError(err));\n                    }).finally(function () {\n                        modal.dismiss('cancel');\n                    });\n            });\n    };\n\n    $scope.delete = function (inst, type) {\n        const isExternal = type.key.indexOf(\"Elastic\") >= 0 || type.key.indexOf(\"Solr\") >= 0;\n\n        $modal.open({\n            templateUrl: 'js/angular/externalsync/templates/deleteConnector.html',\n            controller: 'DeleteConnectorCtrl',\n            resolve: {\n                type: function () {\n                    return type.key;\n                },\n                isExternal: function () {\n                    return isExternal;\n                }\n            }\n        }).result\n            .then(function(force) {\n                $scope.setLoader(true, 'Deleting connector ' + inst.name, 'This is usually a fast operation but it might take a while.');\n\n                const query = deleteConnectorQuery(inst.name, type.value, force);\n                RDF4JRepositoriesRestService.addStatements($repositories.getActiveRepository(), jsonToFormData({update: query}))\n                    .then(function () {\n                        ConnectorsRestService.getConnectors().then(function () {\n                            ConnectorsRestService.hasConnector(encodeURIComponent(type.value)).then(function (res) {\n                                $scope.existing[type.key] = res.data;\n                            });\n                        });\n                        if (force) {\n                            toastr.success(\"Deleted (with force) connector \" + inst.name);\n                            if (isExternal) {\n                                toastr.warning(\"You may have to remove the index manually from \" + type.key);\n                            }\n                        } else {\n                            toastr.success(\"Deleted connector \" + inst.name);\n                        }\n                    }, function (err) {\n                        toastr.error(getError(err));\n                    }).finally(function() {\n                        $scope.setLoader(false);\n                    });\n            });\n    };\n\n    $scope.viewQuery = function (connector, inst) {\n        $modal.open({\n            templateUrl: 'pages/viewQuery.html',\n            controller: 'ViewQueryCtrl',\n            resolve: {\n                query: function () {\n                    const options = $scope.getOptions(connector);\n                    return createConnectorQuery(inst.name, connector.value,\n                        mapCreateValuesToUiValues(inst.values, options), options);\n                }\n            }\n        });\n    };\n}\n\nDeleteConnectorCtrl.$inject = ['$scope', '$modalInstance', 'type', 'isExternal'];\nfunction DeleteConnectorCtrl($scope, $modalInstance, type, isExternal) {\n    $scope.force = false;\n    $scope.type = type;\n    $scope.isExternal = isExternal;\n\n    $scope.ok = function () {\n        $modalInstance.close($scope.force);\n    };\n\n    $scope.cancel = function () {\n        $modalInstance.dismiss();\n    };\n}\n\nExtendNewConnectorCtrl.$inject = ['$scope', '$modalInstance', 'connector', '$modal', 'toastr'];\nfunction ExtendNewConnectorCtrl($scope, $modalInstance, connector, $modal, toastr) {\n\n    $scope.connector = connector;\n\n    $scope.addField = function (index, optionName) {\n        const newField = angular.copy($scope.defaultValues[optionName][0]);\n        $scope.values[optionName].splice(index + 1, 0, newField);\n    };\n\n    $scope.addOption = function (index, array) {\n        array.splice(index + 1, 0, '');\n    };\n\n    $scope.deleteOption = function (index, array) {\n        array.splice(index, 1);\n    };\n\n    $scope.addMapOption = function (index, array) {\n        array.splice(index + 1, 0, {key: '', value: ''});\n    };\n\n    $scope.deleteMapOption = function (index, array) {\n        array.splice(index, 1);\n    };\n\n    function toQuery() {\n        return createConnectorQuery($scope.name, connector.value, $scope.values, $scope.options,\n            function (label, error) {\n                toastr.error(error, label);\n            });\n    }\n\n    $scope.ok = function () {\n        if ($scope.form.$valid) {\n            const query = toQuery();\n\n            if (query) {\n                $modalInstance.close({name: $scope.name, values: $scope.values, options: $scope.options, query: query});\n            }\n        }\n    };\n\n    $scope.viewQuery = function () {\n        const query = toQuery();\n\n        if (query) {\n            $modal.open({\n                templateUrl: 'pages/viewQuery.html',\n                controller: 'ViewQueryCtrl',\n                resolve: {\n                    query: function () {\n                        return query;\n                    }\n                }\n            });\n        }\n    };\n\n    $scope.cancel = function () {\n        $modalInstance.dismiss('cancel');\n    };\n}\n\nCreateConnectorCtrl.$inject = ['$scope', '$controller', '$http', '$modalInstance', 'connector', '$modal', 'values', 'options'];\n\nfunction CreateConnectorCtrl($scope, $controller, $http, $modalInstance, connector, $modal, values, options) {\n    angular.extend(this, $controller('ExtendNewConnectorCtrl', {\n        $scope: $scope,\n        $modalInstance: $modalInstance,\n        connector: connector,\n        $modal: $modal\n    }));\n    $scope.values = values.values;\n    $scope.options = options;\n    $scope.name = values.name;\n    if (!values.skipConversion) {\n        $scope.values = mapCreateValuesToUiValues($scope.values, $scope.options);\n    }\n    $scope.defaultValues = angular.copy($scope.values);\n}\n\n// Note that this is a fancy controller: it's used both for a modal and for a directive.\n// This means you can't rely on custom injection through resolve in the modal and the scope\n// must be shared with the main connectors controller.\nCreateProgressCtrl.$inject = ['$scope', '$interval', '$http', '$repositories'];\n\nfunction CreateProgressCtrl($scope, $interval, $http, $repositories) {\n    function evaluateSparqlQuery(query) {\n        return _evaluateSparqlQuery($http, $repositories.getActiveRepository(), query);\n    }\n\n    function initProgress() {\n        const query = createStatusQueryForIri($scope.beingBuiltConnector.iri);\n\n        // reset iri value so that watch will fire again when we do something with the same connector\n        $scope.beingBuiltConnector.iri = null;\n\n        $scope.progressInterval = $interval(function () {\n            function getFirstStatusFromResult(results) {\n                if (results.bindings) {\n                    if (results.bindings.length > 0) {\n                        try {\n                            return JSON.parse(results.bindings[0].status.value);\n                        } catch (e) {\n                            console.error(e); // eslint-disable-line no-console\n                        }\n                    }\n                }\n\n                return {};\n            }\n\n            evaluateSparqlQuery(query)\n                .then(function (res) {\n                    const status = getFirstStatusFromResult(res.data.results);\n                    if (status.status === 'BUILDING') {\n                        $scope.beingBuiltConnector.status = status;\n                        $scope.beingBuiltConnector.percentDone = (100 * status.processedEntities / status.estimatedEntities).toFixed(0);\n                        $scope.beingBuiltConnector.eta = $scope.getHumanReadableSeconds(status.etaSeconds);\n                        $scope.beingBuiltConnector.actionName = status.repair ? 'Repairing' : 'Creating';\n                        $scope.beingBuiltConnector.waitOnRepairStartOnce = false;\n                    } else if (status.status === 'BUILT' && !$scope.beingBuiltConnector.waitOnRepairStartOnce) {\n                        // done\n                        $interval.cancel($scope.progressInterval);\n                        if ($scope.beingBuiltConnector.doneCallback) {\n                            $scope.beingBuiltConnector.doneCallback();\n                        }\n                    }\n                });\n        }, 1000);\n\n        $scope.$on('$destroy', function () {\n            $interval.cancel($scope.progressInterval);\n        });\n    }\n\n    $scope.beingBuiltConnector = $scope.beingBuiltConnector || {};\n\n    // for modal instance we get the iri before hand and can start progress now\n    if (!$scope.beingBuiltConnector.inline && $scope.beingBuiltConnector.iri) {\n        initProgress();\n    }\n\n    // for inline progress we need to watch for the iri value\n    $scope.$watch('beingBuiltConnector.iri', function (value) {\n        if ($scope.beingBuiltConnector.inline && value) {\n            initProgress();\n        }\n    });\n}\n\nfunction ceil() {\n    return function (input) {\n        return Math.ceil(input);\n    };\n}\n","import 'angular/rest/connectors.rest.service';\nimport 'angular/utils/local-storage-adapter';\nimport 'angular/externalsync/controllers';\nimport YASQE from 'lib/yasqe.bundled';\nimport YASR from 'lib/yasr.bundled';\n\nangular\n    .module('graphdb.framework.core.directives.queryeditor.queryeditor', [\n        'ngCookies',\n        'graphdb.framework.externalsync.controllers',\n        'graphdb.framework.rest.connectors.service',\n        'graphdb.framework.utils.localstorageadapter'\n    ])\n    .directive('queryEditor', queryEditorDirective);\n\nqueryEditorDirective.$inject = ['$timeout', '$location', 'toastr', '$repositories', 'SparqlRestService', 'ModalService', '$modal', '$jwtAuth', 'RDF4JRepositoriesRestService', 'ConnectorsRestService', 'LocalStorageAdapter', 'LSKeys'];\n\nfunction queryEditorDirective($timeout, $location, toastr, $repositories, SparqlRestService, ModalService, $modal, $jwtAuth, RDF4JRepositoriesRestService, ConnectorsRestService, LocalStorageAdapter, LSKeys) {\n\n    let callbackOnChange;\n\n    return {\n        restrict: 'AE',\n        scope: false,\n        templateUrl: 'js/angular/core/directives/queryeditor/templates/query-editor.html',\n        link: linkFunc\n    };\n\n    //function updateLineGutter() in Yasqe receive wrong data and line numbers div have width 100%\n    // magic value 150 seems to work well (including Safari), smaller values work on other browsers but not always on Safari\n    function linkFunc(scope, element, attrs) {\n        // Doesn't store anything in local storage\n        scope.nostorage = attrs.hasOwnProperty('nostorage');\n        // Doesn't allow multiple tabs in the editor, only a single tab is active\n        scope.notabs = attrs.hasOwnProperty('notabs');\n        // Hides all the vertical toolbar inside the editor\n        scope.notoolbar = attrs.hasOwnProperty('notoolbar');\n        // Hides the saved queries icons in the toolbar\n        scope.notoolbarSaved = attrs.hasOwnProperty('notoolbarSaved');\n        // Hides the copy query link icon in the toolbar\n        scope.notoolbarCopy = attrs.hasOwnProperty('notoolbarCopy');\n        // Hides the inference icon in the toolbar\n        scope.notoolbarInference = attrs.hasOwnProperty('notoolbarInference');\n        // Hides the sameAs icon in the toolbar\n        scope.notoolbarSameAs = attrs.hasOwnProperty('notoolbarSameAs');\n        // Doesn't show any status messages in YASR (e.g. no results, query took that many seconds, etc)\n        scope.nostatus = attrs.hasOwnProperty('nostatus');\n        // Doesn't show the run button\n        scope.norun = attrs.hasOwnProperty('norun');\n        // Name of the Run button in the editor\n        scope.runButtonName = \"Run\";\n        if (attrs.runButtonName) {\n            scope.runButtonName = attrs.runButtonName;\n        }\n        // Doesn't execute the count query\n        scope.nocount = attrs.nocount === \"true\";\n\n        // Custom callback to call when the content changes (fired within timeout of 200)\n        if (attrs.callbackOnChange) {\n            const callback = scope[attrs.callbackOnChange];\n            if (typeof callback === 'function') {\n                callbackOnChange = callback;\n            }\n        }\n\n        $timeout(function () {\n            drawQueryEditor(scope);\n        }, 150);\n    }\n\n    function drawQueryEditor(scope) {\n        scope.changePagination = changePagination;\n\n        // start of keyboard shortcut actions\n        function saveQueryAction() {\n            angular.element('#wb-sparql-saveQuery')[0].click();\n        }\n\n        function runQueryAction() {\n            scope.runQuery(false, false);\n        }\n\n        function explainQueryAction() {\n            scope.runQuery(false, true);\n        }\n\n        function goToNextTabAction() {\n            if (scope.tabs.length < 2 || !scope.currentQuery.id || !scope.isTabChangeOk(false)) {\n                return;\n            }\n            let idx = findTabIndexByID(scope.currentQuery.id);\n            idx = (idx + 1) % scope.tabs.length;\n            const tab = scope.tabs[idx];\n            selectTab(tab.id);\n        }\n\n        function goToPreviousTabAction() {\n            if (scope.tabs.length < 2 || !scope.currentQuery.id || !scope.isTabChangeOk(false)) {\n                return;\n            }\n            let idx = findTabIndexByID(scope.currentQuery.id);\n            idx--;\n            if (idx === -1) {\n                idx = scope.tabs.length - 1;\n            }\n            const tab = scope.tabs[idx];\n            selectTab(tab.id);\n        }\n\n        window.editor = YASQE.fromTextArea(\n            document.getElementById(\"query\"), {\n                persistent: null,\n                value: \"\",\n                indentUnit: 4,\n                createShareLink: null,\n                cursorHeight: 1.0,\n                sparql: {\n                    showQueryButton: false,\n                    acceptHeaderGraph: \"application/x-graphdb-table-results+json, application/rdf+json;q=0.9, */*;q=0.8\",\n                    acceptHeaderSelect: \"application/x-sparqlstar-results+json, application/sparql-results+json;q=0.9, */*;q=0.8\"\n                },\n                // We provide a wrapper for executeQuery so we have to redefine those here\n                extraKeys: {\n                    \"Ctrl-Enter\": runQueryAction,\n                    \"Cmd-Enter\": runQueryAction,\n                    \"Shift-Ctrl-Enter\": explainQueryAction,\n                    \"Shift-Cmd-Enter\": explainQueryAction,\n                    \"Ctrl-Alt-T\": scope.addNewTab,\n                    \"Cmd-Alt-T\": scope.addNewTab,\n                    \"Ctrl-S\": saveQueryAction,\n                    \"Cmd-S\": saveQueryAction,\n                    \"Ctrl-Alt-Left\": goToPreviousTabAction,\n                    \"Cmd-Alt-Left\": goToPreviousTabAction,\n                    \"Ctrl-Alt-Right\": goToNextTabAction,\n                    \"Cmd-Alt-Right\": goToNextTabAction\n                }\n            }\n        );\n\n        window.editor.toastBuildIndex = function () {\n            toastr.warning('', '<div class=\"autocomplete-toast\"><a href=\"autocomplete\">Autocomplete is OFF<br>Go to Setup -> Autocomplete</a></div>',\n                {allowHtml: true});\n        };\n\n        window.editor.toastError = function (data) {\n            toastr.error('Cannot execute autocomplete query. ' + getError(data));\n        };\n\n        window.editor.on(\"changes\", function () {\n            angular.element('.CodeMirror-linenumbers').css('width', '1px');\n            angular.element('.CodeMirror-sizer').css('margin-left', '0px');\n            clearTimeout(scope.changesTimeout);\n            const hasError = !window.editor.queryValid;\n            scope.changesTimeout = setTimeout(callbackOnChange ? callbackOnChange() : function () {\n                const idx = findTabIndexByID(scope.currentQuery.id) + 1;\n                $('a[data-id = \"' + idx + '\"]')\n                    .toggleClass('query-has-error', hasError)\n                    .attr('title', hasError ?\n                        'Query contains a syntax error. See the relevant line for more information.' :\n                        '');\n            }, 200);\n            scope.currentQuery.query = window.editor.getValue();\n            scope.currentQuery.queryType = window.editor.getQueryType();\n        });\n\n\n        function selectTab(id) {\n            $timeout(function () {\n                let requestedTab = $('a[data-id = \"' + id + '\"]');\n                if (requestedTab.length === 0) {\n                    // tab has been deleted in another browser window or something else occurred,\n                    // select first tab instead\n                    requestedTab = $('a[data-id]').first();\n                }\n                requestedTab.tab('show');\n            }, 0);\n        }\n\n        // hide unneeded yasqe fullscreen button\n        $(\".fullscreenToggleBtns\").hide();\n\n        const afterCopy = function (event) {\n            $(event.target).removeClass('fa-link').addClass('fa-check').blur();\n            setTimeout(function () {\n                $(event.target).removeClass('fa-check').addClass('fa-link');\n            }, 1000);\n        };\n\n        window.onbeforeunload = function () {\n            if (!scope.nostorage) {\n                LocalStorageAdapter.set(LSKeys.TABS_STATE, scope.tabs);\n            }\n            scope.saveTab(scope.currentQuery.id);\n        };\n\n        /*\n         * Patch the execute query to take into account the inference\n         * and the same as options\n         */\n        const originalExecuteQuery = YASQE.executeQuery;\n        const originalGetUrlArguments = YASQE.getUrlArguments;\n\n        scope.$on('$destroy', function () {\n            if (!scope.nostorage) {\n                LocalStorageAdapter.set(LSKeys.TABS_STATE, scope.tabs);\n            }\n            YASQE.executeQuery = originalExecuteQuery;\n            YASQE.getUrlArguments = originalGetUrlArguments;\n            scope.saveTab(scope.currentQuery.id);\n        });\n\n        /*\n         * Add our own buttons\n         */\n        YASQE.drawButtons = function (yasqe) {\n            // Define this property because otherwise there are errors in yasgui's code.\n            yasqe.buttons = $(\"#yasqe_buttons_mocked\");\n        };\n\n        YASQE.getActiveRepository = function () {\n            return $repositories.getActiveRepository();\n        };\n\n        YASQE.getUrlArguments = function (yasqe, config) {\n            const data = originalGetUrlArguments(yasqe, config);\n            const qType = window.editor.getQueryType();\n            if ('SELECT' === qType || 'CONSTRUCT' === qType || 'DESCRIBE' === qType) {\n                // We request pageSize + 1 to know if there are more pages when total count isn't known\n                data.push({name: 'limit', value: scope.currentTabConfig.pageSize + 1});\n                scope.currentTabConfig.offset = (scope.currentTabConfig.page - 1) * scope.currentTabConfig.pageSize + 1;\n                data.push({name: 'offset', value: scope.currentTabConfig.offset - 1});\n            }\n            // even though we have explainRequested in our scope too it doesn't always contain a fresh value\n            if (scope.explainRequested && ('SELECT' === qType || 'CONSTRUCT' === qType)) {\n                data.push({name: 'explain', value: 'true'});\n            }\n            return data;\n        };\n\n        function createCustomError(status, statusText, responseText) {\n            return {\n                status: status,\n                statusText: statusText,\n                responseText: responseText\n            };\n        }\n\n        // Generates a new tracking alias for queries based on time\n        function newTrackAlias() {\n            return \"query-editor-\" + performance.now() + \"-\" + Date.now();\n        }\n\n        let connectorProgressModal;\n        let yasr;\n\n        YASQE.executeQuery = function (cm) {\n            if (yasr && $(yasr.resultsContainer).length) {\n                $(yasr.resultsContainer).empty();\n            }\n            // Request extra error/warning handling\n            cm.options.sparql.headers['X-GraphDB-Catch'] = scope.currentTabConfig.pageSize + '; throw';\n            scope.currentTrackAlias = newTrackAlias();\n            cm.options.sparql.headers['X-GraphDB-Track-Alias'] = scope.currentTrackAlias;\n            scope.countTimeouted = false;\n            if (cm.getQueryMode() === 'query') {\n                cm.options.sparql.endpoint = 'repositories/' + $repositories.getActiveRepository();\n            } else if (cm.getQueryMode() === 'update') {\n                cm.options.sparql.endpoint = 'repositories/' + $repositories.getActiveRepository() + '/statements';\n            }\n            cm.options.sparql.args = [{\n                name: 'infer',\n                value: scope.currentQuery.inference\n            },\n                {\n                    name: 'sameAs',\n                    value: scope.currentQuery.sameAs\n                }];\n\n            scope.currentTabConfig.customUpdateMessage = \"\";\n\n            if (window.editor.getQueryMode() === \"update\") {\n                const doExecute = function () {\n                    scope.currentTabConfig.queryType = \"UPDATE\";\n\n                    RDF4JRepositoriesRestService.getRepositorySize()\n                        .success(function (data) {\n                            scope.repoSize = parseInt(data);\n                            scope.queryStartTime = new Date().getTime();\n                            return originalExecuteQuery(cm, {});\n                        })\n                        .error(function (data) {\n                            toastr.warning('Could not get repository size for: ' + $repositories.getActiveRepository() + '; ' + getError(data));\n                            scope.queryStartTime = new Date().getTime();\n                            return originalExecuteQuery(cm, {});\n                        });\n                };\n\n                ConnectorsRestService.checkConnector(window.editor.getValue())\n                    .then(function (res) {\n                        if (res.data.command && !res.data.hasSupport) {\n                            // it's a connector query but the relevant plugin isn't active, stop executing and warn the user\n                            scope.currentTabConfig.queryType = 'ERROR';\n                            scope.currentTabConfig.timeFinished = Date.now();\n                            scope.currentTabConfig.timeTook = (scope.currentTabConfig.timeFinished - scope.queryStartTime) / 1000;\n\n                            const customError = createCustomError(-1, 'No support for ' + res.data.connectorName, res.data.connectorName\n                                + ' connectors are not supported because the plugin ' + res.data.pluginName + ' is not active.');\n\n                            yasr.results = {\n                                getException: function () {\n                                    return customError;\n                                }\n                            };\n\n                            scope.setLoader(false);\n\n                            setNewTabState({customError: customError}, '', null);\n\n                            return;\n                        }\n\n                        if (res.data.command === 'create' || res.data.command === 'repair') {\n                            const repair = res.data.command === 'repair';\n                            if (repair) {\n                                scope.setLoader(true, 'Repairing connector ' + res.data.name);\n                                scope.currentTabConfig.customUpdateMessage = 'Repaired connector ' + res.data.name + '.';\n                            } else {\n                                scope.setLoader(true, 'Creating connector ' + res.data.name);\n                                scope.currentTabConfig.customUpdateMessage = 'Created connector ' + res.data.name + '.';\n                            }\n\n                            const progressScope = scope.$new(true);\n\n                            // This duplicates code in the externalsync module but we can't get it from there\n                            progressScope.beingBuiltConnector = {\n                                percentDone: 0,\n                                status: {\n                                    processedEntities: 0,\n                                    estimatedEntities: 0,\n                                    indexedEntities: 0,\n                                    entitiesPerSecond: 0\n                                },\n                                actionName: repair ? 'Repairing' : 'Creating',\n                                eta: \"-\",\n                                inline: false,\n                                iri: res.data.iri,\n                                name: res.data.name,\n                                doneCallback: function () {\n                                    connectorProgressModal.dismiss('cancel');\n                                }\n                            };\n                            progressScope.getHumanReadableSeconds = scope.getHumanReadableSeconds;\n\n                            connectorProgressModal = $modal.open({\n                                templateUrl: 'pages/connectorProgress.html',\n                                controller: 'CreateProgressCtrl',\n                                size: 'lg',\n                                backdrop: 'static',\n                                scope: progressScope\n                            });\n                        } else if (res.data.command === 'drop') {\n                            scope.setLoader(true, 'Deleting connector ' + res.data.name);\n                            scope.currentTabConfig.customUpdateMessage = 'Deleted connector ' + res.data.name + '.';\n                        }\n\n                        doExecute();\n                    }, function () {\n                        // for some reason we couldn't check if this is a connector update, so just execute it\n                        doExecute();\n                    });\n\n            } else {\n                const thisTabConfig = scope.currentTabConfig;\n                const thisTabId = scope.executedQueryTab.id;\n\n                // Assign a fresh callback function so that we can associate the count result\n                // with the right tab (or lack of tab).\n                window.editor.options.sparql.handlers.countCallback = function (dataOrJqXhr, textStatus, jqXhrOrErrorString) {\n                    if (dataOrJqXhr.status === 200) {\n                        const tab = scope.tabs[findTabIndexByID(thisTabId)];\n                        if (tab) {\n                            yasr.setResultsCount(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n                            thisTabConfig.allResultsCount = yasr.allCount;\n                            tab.allResultsCount = yasr.allCount;\n                            thisTabConfig.allResultsCountExact = true;\n                            tab.allResultsCountExact = true;\n                            scope.saveTab(tab.id);\n                        } // Else tab was closed while we wait for the count, ignore result\n                    } else {\n                        // count query timed out or something else went wrong\n                        thisTabConfig.countTimeouted = true;\n                    }\n                };\n\n                // Tell YASR what format we want, or else it will mess it up when switching between tabs.\n                if (scope.currentQuery.outputType != null) {\n                    yasr.options.output = scope.currentQuery.outputType;\n                } else { // Default to table if no format has been configured yet.\n                    yasr.options.output = \"table\";\n                }\n                scope.currentTabConfig.queryType = window.editor.getQueryType();\n                scope.queryStartTime = new Date().getTime();\n                return originalExecuteQuery(cm, {\n                    setQueryLimit: function (query) {\n                        // Until weird conversion of CONSTRUCT queries is fixed\n                        // in Ontop project, comments should be removed from them\n                        // TODO: Remove this check when ${link https://github.com/ontop/ontop/issues/362} is fixed\n                        if (scope.currentTabConfig.queryType === 'CONSTRUCT' && $repositories.isActiveRepoOntopType()) {\n                            return window.editor.getValueWithoutComments();\n                        }\n                        // For all types of queries we handle limit/offset in our RepositoriesController.\n                        // TODO: Get rid of this method\n                        return query;\n                    }\n                });\n            }\n\n        };\n\n        // Override yasqe's getAjaxConfig() so we can inject our authorization header\n        const originalGetAjaxConfig = YASQE.getAjaxConfig;\n        YASQE.getAjaxConfig = function (yasqe, callbackOrConfig) {\n            const config = originalGetAjaxConfig(yasqe, callbackOrConfig);\n\n            _.extend(config.headers, {\n                'Authorization': $jwtAuth.getAuthToken()\n            });\n\n            return config;\n        };\n\n        function createQueryURL(savedQueryName, owner) {\n            let url = [location.protocol, '//', location.host, location.pathname].join('');\n            if (savedQueryName) {\n                url = url + '?savedQueryName=' + encodeURIComponent(savedQueryName);\n                if (owner != null) {\n                    url += '&owner=' + encodeURIComponent(owner);\n                }\n            } else {\n                url = url + '?' + $.param({\n                    name: scope.currentQuery.name,\n                    infer: scope.currentQuery.inference,\n                    sameAs: scope.currentQuery.sameAs,\n                    query: window.editor.getValue()\n                });\n            }\n            return url;\n        }\n\n        scope.copyToClipboardQuery = function (savedQueryName, owner) {\n            ModalService.openCopyToClipboardModal(createQueryURL(savedQueryName, owner));\n        };\n\n        scope.copyToClipboardResult = function (resultURI) {\n            ModalService.openCopyToClipboardModal(resultURI);\n        };\n\n        scope.goToVisual = function () {\n            const paramsToParse = {\n                query: window.editor.getValue(),\n                sameAs: scope.currentQuery.sameAs,\n                inference: scope.currentQuery.inference\n            };\n\n            $location.path('graphs-visualizations').search(paramsToParse);\n        };\n\n        // Adds prefixes when the user pastes a query. This was in the controller before and it stopped working\n        // (needs to happen to after YASQE adds the textarea), see GDB-1936\n        $('textarea').on('paste', function () {\n            $timeout(function () {\n                scope.addKnownPrefixes();\n            }, 0);\n        });\n\n        function setNewTabState(dataOrJqXhr, textStatus, jqXhrOrErrorString) {\n            // store explicitly the contentType\n            if (dataOrJqXhr.getResponseHeader && dataOrJqXhr.getResponseHeader(\"content-type\")) {\n                dataOrJqXhr.contentType = dataOrJqXhr.getResponseHeader(\"content-type\");\n            }\n\n            // We use this when we set YASR results to avoid double JSON parsing and to enforce\n            // using the modified responseJSON. We'll save responseJSON instead (no need to save both).\n            delete dataOrJqXhr.response;\n\n            const executedQueryTabIdx = findTabIndexByID(scope.executedQueryTab.id);\n            const executedQueryTab = scope.tabs[executedQueryTabIdx];\n            const queryResultState = {\n                    queryType: scope.currentTabConfig.queryType,\n                    yasrData: dataOrJqXhr,\n                    textStatus: textStatus,\n                    jqXhrOrErrorString: jqXhrOrErrorString,\n                    page: scope.currentTabConfig.page,\n                    pageSize: scope.currentTabConfig.pageSize,\n                    allResultsCount: scope.currentTabConfig.allResultsCount,\n                    allResultsCountExact: scope.currentTabConfig.allResultsCountExact,\n                    resultsCount: scope.currentTabConfig.resultsCount,\n                    offset: scope.currentTabConfig.offset,\n                    timeTook: scope.currentTabConfig.timeTook,\n                    timeFinished: scope.currentTabConfig.timeFinished,\n                    sizeDelta: scope.currentTabConfig.sizeDelta,\n                    customUpdateMessage: scope.currentTabConfig.customUpdateMessage,\n                    errorMessage: scope.currentTabConfig.errorMessage,\n                    warningMessage: scope.currentTabConfig.warningMessage\n                };\n\n            // Save the output type only if it isn't an update or an ask query.\n            // This way we preserve the existing output type when we execute an update and then\n            // execute a non-ask query.\n            if (scope.currentTabConfig.queryType !== \"ERROR\" && scope.currentTabConfig.queryType !== \"UPDATE\"\n                && scope.currentTabConfig.queryType !== \"ASK\") {\n                queryResultState.outputType = scope.yasr.options.output;\n            }\n\n            // merge query results state with the tab object\n            angular.extend(scope.currentQuery, queryResultState);\n\n            angular.extend(executedQueryTab, queryResultState);\n            if (!scope.nostorage) {\n                LocalStorageAdapter.set(LSKeys.TABS_STATE, scope.tabs);\n            }\n            $('a[data-id = \"' + scope.executedQueryTab.id + '\"]').tab('show');\n        }\n\n        function initYasr() {\n            yasr = YASR(document.getElementById(\"yasr\"), { // eslint-disable-line new-cap\n                getUsedPrefixes: {}, // initially blank, populated when we fetch the namespaces\n                persistency: false\n            });\n            window.yasr = yasr;\n            yasr.afterCopy = afterCopy;\n            yasr.getQueryResultsAsFormat = function (downloadFormat) {\n                // Simple cross-browser download with a form\n                const $wbDownload = $('#wb-download');\n                $wbDownload.attr('action', 'repositories/' + $repositories.getActiveRepository());\n                $('#wb-download-query').val(scope.currentQuery.query);\n                if (window.editor.getValue() !== scope.currentQuery.query) {\n                    toastr.warning('The query in your editor does not match the query results. Download will save the results from the last executed query.');\n                }\n                $('#wb-download-infer').val(scope.currentQuery.inference);\n                $('#wb-download-sameAs').val(scope.currentQuery.sameAs);\n                const auth = localStorage.getItem('com.ontotext.graphdb.auth');\n                if (auth) {\n                    $('#wb-auth-token').val(auth);\n                }\n                $('#wb-download-accept').val(downloadFormat);\n                $wbDownload.submit();\n            };\n            window.editor.options.sparql.handlers.complete = function (dataOrJqXhr, textStatus, jqXhrOrErrorString) {\n                function setNewTabStateForThis() {\n                    setNewTabState(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n                }\n\n                if (connectorProgressModal) {\n                    connectorProgressModal.dismiss('cancel');\n                }\n\n                // If yasqe was destroyed when scope was destroyed, do nothing\n                if (null === window.editor) {\n                    scope.setLoader(false);\n\n                    return;\n                }\n\n                // Extra error/warning through headers\n                scope.currentTabConfig.errorMessage = dataOrJqXhr.getResponseHeader('X-GraphDB-Error');\n                scope.currentTabConfig.warningMessage = dataOrJqXhr.getResponseHeader('X-GraphDB-Warning');\n\n                yasr.currentQuery = scope.currentQuery;\n\n                scope.currentTabConfig.timeFinished = Date.now();\n                scope.currentTabConfig.timeTook = (scope.currentTabConfig.timeFinished - scope.queryStartTime) / 1000;\n\n                if (dataOrJqXhr.status >= 400) {\n                    // Removes useless com.blah.whatever.FooException: ... from the error message\n                    dataOrJqXhr.responseText = dataOrJqXhr.responseText.replace(/^([^: ]+: )+/, '');\n\n                    scope.currentTabConfig.queryType = 'ERROR';\n                    setNewTabStateForThis();\n                    scope.setYasrResponse(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n\n                    scope.setLoader(false);\n\n                    return;\n                }\n\n                if (dataOrJqXhr.status === 0) {\n                    // Query was aborted, typically through window.editor.xhr.abort()\n\n                    scope.currentTabConfig.queryType = 'ERROR';\n\n                    const customError = createCustomError(-1, 'Request was aborted', 'The request has been aborted. There are no results to show.');\n\n                    yasr.results = {\n                        getException: function () {\n                            return customError;\n                        }\n                    };\n\n                    scope.setLoader(false);\n\n                    setNewTabState({customError: customError}, '', null);\n\n                    return;\n                }\n\n                scope.setLoader(false);\n\n                let updateResultsCallback;\n\n                if (window.editor.getQueryMode() === \"update\") {\n                    updateResultsCallback = function () {\n                        RDF4JRepositoriesRestService.getRepositorySize()\n                            .success(function (data) {\n                                let repoSizeDiff;\n                                if (scope.repoSize !== undefined) {\n                                    repoSizeDiff = Number(data) - scope.repoSize;\n                                }\n                                scope.currentTabConfig.sizeDelta = repoSizeDiff;\n                                setNewTabStateForThis();\n                            }).error(function (data) {\n                                toastr.warning('Could not get repository size for: ' + scope.getActiveRepository() + '; ' + getError(data));\n                                scope.currentTabConfig.sizeDelta = undefined;\n                                setNewTabStateForThis();\n                            });\n                    };\n                } else {\n                    if (dataOrJqXhr.status === 200) {\n                        const contentType = dataOrJqXhr.getResponseHeader('Content-Type');\n\n                        if (contentType.indexOf('application/sparql-results+json') === 0\n                            || contentType.indexOf('application/x-sparqlstar-results+json') === 0\n                            || contentType.indexOf('application/x-graphdb-table-results+json') === 0) {\n                            if (dataOrJqXhr.responseJSON.results) {\n                                // SELECT results in one of the standard formats or\n                                // CONSTRUCT or DESCRIBE results in our custom format that looks\n                                // like a SELECT result.\n                                scope.currentTabConfig.resultsCount = dataOrJqXhr.responseJSON.results.bindings.length;\n                                if (dataOrJqXhr.responseJSON.results.bindings.length > scope.currentTabConfig.pageSize) {\n                                    // The results are more than the page size (because we request +1), truncate to page size\n                                    // and raise flag to know we have at least one page more.\n                                    dataOrJqXhr.responseJSON.results.bindings.length = scope.currentTabConfig.pageSize;\n                                }\n                                if (!scope.currentTabConfig.allResultsCountExact) {\n                                    if (scope.nocount || scope.countTimeouted\n                                        || scope.currentTabConfig.resultsCount <= scope.currentTabConfig.pageSize) {\n                                        // No count requested or count timed out or the results are less than the pageSize + 1 buffer\n                                        // In all of these cases it doesn't make sense to run\n                                        // the counting query so we tweak the status to signal that to YASQE.\n                                        dataOrJqXhr.status = 204; // 204 is no content, YASQE counts only if status is 200\n                                    }\n\n                                    // Calculate an \"at least\" all results count, i.e. at least what we have until now + 1.\n                                    // The number will increase when we go to the next page eventually reaching the exact count.\n                                    // A count query may also provide the exact count asynchronously.\n                                    scope.currentTabConfig.allResultsCount = Math.max(scope.currentTabConfig.allResultsCount,\n                                        scope.currentTabConfig.pageSize * (scope.currentTabConfig.page - 1) + scope.currentTabConfig.resultsCount);\n\n                                    // We know we reached the end and the count is exact now.\n                                    if (scope.currentTabConfig.resultsCount <= scope.currentTabConfig.pageSize) {\n                                        scope.currentTabConfig.allResultsCountExact = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    // The following long-running code needs to be in timeout to get the updated loader message\n                    scope.setLoader(true, 'Rendering results', null, true);\n\n                    updateResultsCallback = function () {\n                        scope.setYasrResponse(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n\n                        setNewTabStateForThis();\n                        scope.setLoader(false);\n                    };\n                }\n\n                // By having this in timeout we manage to get the updated loader message\n                $timeout(function () {\n                    updateResultsCallback();\n\n                    // Move disabled class to a, and clean from the li\n                    if (window.editor.getQueryType() !== \"CONSTRUCT\") {\n                        $('.yasr_btnGroup.nav.nav-tabs li a.disabled').removeClass('disabled').css('font-weight', '400');\n                        $('.yasr_btnGroup.nav.nav-tabs li.disabled a').addClass('disabled').css('font-weight', '200');\n                        if (window.editor.getQueryType() === \"DESCRIBE\") {\n                            $('.yasr_btnGroup.nav.nav-tabs li a').removeClass('disabled').css('font-weight', '400');\n                        }\n                    } else if (window.editor.getQueryType() === \"CONSTRUCT\") {\n                        $('.yasr_btnGroup.nav.nav-tabs li a.disabled').removeClass('disabled').css('font-weight', '400');\n                    }\n\n\n                    //Remove paddign of yasr so it will be aligned with sparql editor\n                    $('#yasr').css('padding', '0');\n\n                    if ($('.yasr_btnGroup li:nth-child(2)').hasClass(\"active\")) {\n                        $timeout(function () {\n                            $('.yasr_btnGroup li:nth-child(2) a').get(0).click();\n                        }, 100);\n                    }\n\n                    //\n                    $('#wb-sparql-addNewTab').click(function () {\n                        $('.dataTables_filter').hide();\n                        $('.resultsTable').hide();\n                    });\n                }, 100);\n            };\n\n            window.editor.options.sparql.handlers.resetResults = function () {\n            };\n\n            scope.yasr = yasr;\n\n            scope.setYasrResponse = function(dataOrJqXhr, textStatus, jqXhrOrErrorString) {\n                // If YASR doesn't see a \"response\" property it will parse the textual JSON in \"responseText\".\n                // This is both slow and interferes with the +1 result per page policy when we truncate responseJSON.\n                if (dataOrJqXhr.responseJSON) {\n                    dataOrJqXhr.response = dataOrJqXhr.responseJSON;\n                    dataOrJqXhr.responseText = undefined;\n                }\n                yasr.setResponse(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n            };\n\n            // Track changes in the output type (tab in yasr) so that we can save this together with\n            // the rest of the tab's data.\n            scope.$watch('yasr.options.output', function (value) {\n                // Save the output type only if it isn't an update or an ask query (see comment where we save all properties).\n                if (value && scope.currentTabConfig.queryType !== \"UPDATE\" && scope.currentTabConfig.queryType !== \"ASK\") {\n                    const tab = scope.tabs[findTabIndexByID(scope.currentQuery.id)];\n                    // Do not save tab on default yasr initalization since default table overrides saved value\n                    if (angular.isDefined(tab) && scope.currentTabConfig.queryType) {\n                        if (tab.outputType !== value) {\n                            tab.outputType = scope.currentQuery.outputType = value;\n                            scope.saveTab(tab.id);\n                        }\n                    }\n                }\n            });\n\n            scope.$watch('namespaces', function () {\n                if (scope.namespaces) {\n                    if (yasr && yasr.options && scope.namespaces) {\n                        // this way, the URLs in the results are prettified using the defined prefixes\n                        yasr.options.getUsedPrefixes = scope.namespaces;\n                    }\n\n                    // Notify YASQE about the new namespaces\n                    YASQE.signal(window.editor, 'namespacesChanged', scope.namespaces);\n                }\n            });\n        }\n\n        initYasr();\n\n        function changePagination() {\n            scope.runQuery(true, scope.explainRequested);\n        }\n\n        // Hide the sample queries when the user clicks somewhere else in the UI.\n        $(document).mouseup(function (event) {\n            const container = $('#sampleQueriesCollapse');\n            if (!container.is(event.target) // if the target of the click isn't the container..\n                && container.has(event.target).length === 0 //... nor a descendant of the container\n                && scope.showSampleQueries) {\n                scope.toggleSampleQueries();\n            }\n        });\n\n        function findTabIndexByID(id) {\n            for (let i = 0; i < scope.tabs.length; i++) {\n                const tab = scope.tabs[i];\n                if (tab.id === id) {\n                    return i;\n                }\n            }\n        }\n\n        // functions to load query param or saved queries\n        function toBoolean(v) {\n            return angular.isDefined(v) && v !== 'false';\n        }\n\n        function autoexecuteQueryIfRequested() {\n            const isRequested = toBoolean($location.search().execute);\n\n            if (isRequested) {\n                if (window.editor.getQueryMode() === 'update') {\n                    ModalService.openSimpleModal({\n                        title: 'Confirm execute',\n                        message: 'This is an update and it may change the data in the repository.<br>Are you sure you want to execute it automatically?',\n                        warning: true\n                    }).result\n                        .then(function () {\n                            scope.runQuery(false);\n                        });\n                } else {\n                    scope.runQuery(false);\n                }\n            }\n        }\n\n        function loadQueryIntoExistingOrNewTab(query, infer, sameAs) {\n            const tabId = scope.getExistingTabId(query);\n            // Ah, the joys of non-synchronous events\n            const onHandler = scope.$on('tabLoaded', function () {\n                if (angular.isDefined(infer)) {\n                    scope.currentQuery.inference = toBoolean(infer);\n                }\n                if (angular.isDefined(sameAs)) {\n                    scope.currentQuery.sameAs = toBoolean(sameAs);\n                }\n                autoexecuteQueryIfRequested();\n                onHandler();\n            });\n\n            // See comment about this flag in controller. It's a good idea to be consistent and do this\n            // every time a tab changes without the user clicking on it.\n            scope.highlightNextTabChange = true;\n\n            if (!angular.isDefined(tabId)) {\n                scope.addNewTab(null, query.name, query.body);\n            } else {\n                selectTab(tabId);\n            }\n        }\n\n        function loadSavedQueryIntoExistingOrNewTab(savedQueryName, owner, infer, sameAs) {\n            SparqlRestService.getSavedQuery(savedQueryName, owner)\n                .success(function (data) {\n                    loadQueryIntoExistingOrNewTab(data, infer, sameAs);\n                })\n                .error(function (data) {\n                    toastr.error('Could not get data for saved query: ' + savedQueryName + '; ' + getError(data));\n                });\n        }\n\n        function addTabWithQueryIfNeeded() {\n            if ($location.search().savedQueryName) {\n                // new way\n                loadSavedQueryIntoExistingOrNewTab($location.search().savedQueryName, $location.search().owner,\n                    $location.search().infer, $location.search().sameAs);\n            } else if ($location.search().query) {\n                const query = {name: $location.search().name, body: $location.search().query};\n                loadQueryIntoExistingOrNewTab(query, $location.search().infer, $location.search().sameAs);\n            } else {\n                // Restore the previous tab after the dom has loaded\n                const currentid = LocalStorageAdapter.get(LSKeys.TABS_STATE_CURRENT_ID);\n                selectTab(currentid);\n            }\n        }\n\n        function updateRepositoryAndSecurity() {\n            scope.getNamespaces();\n            YASQE.signal(window.editor, \"repositoryOrAuthorizationChanged\",\n                $repositories.getActiveRepository(), $jwtAuth.getAuthToken());\n            addTabWithQueryIfNeeded();\n        }\n\n        if ($repositories.getActiveRepository()) {\n            updateRepositoryAndSecurity();\n        }\n\n        // When no repo is selected (editor hidden) and the user selects a repo the SPARQL params should be handled\n        scope.$on('repositoryIsSet', function () {\n            if ($repositories.getActiveRepository()) {\n                updateRepositoryAndSecurity();\n            }\n        });\n        // end of repository actions\n\n        // focus the editor\n        $timeout(function () {\n            angular.element(document).find('.CodeMirror textarea:first-child').focus();\n        }, 50);\n\n    }\n}\n"],"sourceRoot":""}