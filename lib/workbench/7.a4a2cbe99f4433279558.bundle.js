(window.webpackJsonp=window.webpackJsonp||[]).push([[7,83],{42:function(e,o){angular.module("graphdb.framework.rest.cluster.service",[]).factory("ClusterRestService",r),r.$inject=["$http"];const t="rest/cluster/masters";function r(e){return{getMaster:function(o,r={}){return e.get(`${t}/${o}`,r)},configureMaster:function(o,r,n){return e({url:`${t}/${o}?masterLocation=${encodeURIComponent(r)}`,method:"POST",data:n})},cloneRepository:function(o){return e.post("rest/cluster/nodes/clone",{cloningNodeLocation:o.currentNodeLocation,cloningNodeRepositoryID:o.selectedNodeName,newNodeRepositoryID:o.repositoryID,newNodeLocation:o.locationUri,newNodeTitle:o.repositoryTitle})},connectWorker:function(o,r,n){return e({url:`${t}/${o}/workers/`,method:"POST",data:{workerURL:n,masterLocation:r}})},disconnectWorker:function(o,r){return e({url:`${t}/${o}/workers?${r}`,method:"DELETE",dataType:"text"})},disconnectNodes:function(o,r){return e({url:`${t}/${o}/peers?${r}`,method:"DELETE",dataType:"text"})},connectNodes:function(o,r){return e({url:`${t}/${o}/peers`,method:"POST",data:r})}}}},81:function(e,o,t){"use strict";t.r(o);t(2),t(42);function r(e){return e.local?"local":e.location.split("/repositories/")[0]}function n(e,o,t,n,s,i,a,c,l,d,u,p,f){e.setLoader=function(o,t){u.cancel(e.loaderTimeout),o?e.loaderTimeout=u((function(){e.loader=o,e.loaderMessage=t}),300):e.loader=!1},e.getLoaderMessage=function(){return e.loaderMessage||"Loading..."},e.getMaster=function(o){p.getMaster(o).success((function(o){e.masterInformation=o}))},e.setMasterAttribute=function(o,t,s){const i={};i[t]=s,e.setLoader(!0,"Setting attribute..."),p.configureMaster(e.getLabel(o.location),r(o),i).success((function(){return e.attributeChange=!1,n.success("Set "+t+" to "+s+".",""),e.refreshMastersIcons(),!0})).error((function(o){return e.attributeChange=!1,n.error(getError(o),"Error setting attribute "+t),!0})).finally((function(){e.setLoader(!1)}))},e.hasInfo=function(o){return null==o||(e.isWorker(o)?"fingerprint"in o:"failedReads"in o)},e.locations=function(){return s.getLocations()},e.showCloneModal=function(){e.clone.locations=e.locations(),e.clone.repositoryID=e.selectedNode.name,i.open({templateUrl:"js/angular/clustermanagement/templates/modal/clone-modal.html",controller:"CloneRepositoryCtrl",resolve:{clone:function(){return e.clone}}}).result.then((function(o){e.clone=o,e.cloneCurrentRepository()}),(function(){e.selectedNode=null}))},e.cloneCurrentRepository=function(){const o=r(e.selectedNode);e.setLoader(!0,"Cloning worker..."),p.cloneRepository({currentNodeLocation:o,selectedNodeName:e.selectedNode.name,repositoryID:e.clone.repositoryID,locationUri:e.clone.location.uri,repositoryTitle:e.clone.repositoryTitle}).success((function(){n.success("Cloned node into "+e.clone.location),e.getNodes()})).error((function(e){n.error(getError(e),"Error cloning node")})).finally((function(){e.setLoader(!1)}))},e.getLabel=function(e){return 0!==e.indexOf("http")?name:e.substring(e.indexOf("/repositories")+14)},e.connectNodes=function(o,t,s){let i,a;if("disabledReason"in o)n.error(o.disabledReason,"Error");else if("disabledReason"in t)n.error(t.disabledReason,"Error");else if("master"!==o.repositoryType||"master"!==t.repositoryType){if("master"===o.repositoryType)i=o,a=t;else{if("master"!==t.repositoryType)return void n.error("You cannot connect two workers","Error");i=t,a=o}a.location in i.workers?n.error("Worker already connected to that master","Error"):(e.setLoader(!0,"Connecting nodes..."),p.connectWorker(e.getLabel(i.location),r(i),a.location).success((function(){const o=Date.now();a.cluster=a.cluster||[],a.cluster.push(i.cluster),e.addOrUpdateLink(i,a,"",o),i.workers[a.location]=1,s(),n.success("Connected worker to master.","")})).error((function(e){n.error(getError(e),"Error connecting worker")})).finally((function(){e.setLoader(!1)})))}else o.location in t.peers&&t.location in o.peers?n.error("Masters already connected","Error"):o.location in t.peers?e.connectMasters(o,t,!1,s):t.location in o.peers?e.connectMasters(t,o,!1,s):e.connectMasters(o,t,!0,s)},e.disconnectLinkConfirm=function(o,t){d.openSimpleModal({title:"Confirm disconnect",message:"Are you sure you want to disconnect the nodes?",warning:!0}).result.then((function(){e.disconnectLink(o,t)}))},e.disconnectLink=function(o,t,s){let i={},a={};"master"===o.source.repositoryType?(i=o.source,a=o.target):"master"===o.target.repositoryType&&(i=o.target,a=o.source),s||!("disabledReason"in i||"master"===a.repositoryType&&"disabledReason"in a)?(e.setLoader(!0,"Disconnecting nodes..."),"worker"===a.repositoryType?function(o,t,s,i){p.disconnectWorker(e.getLabel(t.location),$.param({workerURL:s.location,masterLocation:r(t)})).success((function(){e.deleteLink(o),s.cluster=s.cluster.filter((function(e){return e!==t.cluster})),delete t.workers[s.location],i(),n.success("Disconnected worker from master.","")})).error((function(e){n.error(getError(e),"Error disconnecting worker")})).finally((function(){e.setLoader(!1)}))}(o,i,a,t):function(o,t,s,i){p.disconnectNodes(e.getLabel(t.location),$.param({masterLocation:r(t),masterNodeID:t.nodeID,peerLocation:r(s),peerRepositoryID:e.getLabel(s.location),peerNodeID:s.nodeID})).success((function(r){e.deleteLink(o,!0),delete s.peers[t.location],delete t.peers[s.location],i(),n.success(r,"")})).error((function(e){n.error(getError(e),"Error disconnecting masters")})).finally((function(){e.setLoader(!1)}))}(o,i,a,t)):d.openSimpleModal({title:"Confirm disconnect",message:"One of the masters is currently unreachable and will be disconnected only at the reachable master.<br><br>Proceed only if you know what you are doing.",warning:!0}).result.then((function(){e.disconnectLink(o,t,!0)}))},e.selectNode=function(o){e.selectedNode!==o?e.selectedNode=o:e.selectedNode=null,e.$apply()},e.isWorker=function(e){return null!=e&&"worker"===e.repositoryType},e.connectMasters=function(o,t,r,s){const i=o.location.split("/repositories/"),a=t.location.split("/repositories/");e.setLoader(!0,"Connecting nodes..."),p.connectNodes(i[1],{masterLocation:o.local?"local":i[0],masterNodeID:o.nodeID,peerLocation:t.local?"local":a[0],peerRepositoryID:a[1],peerNodeID:t.nodeID,bidirectional:r}).success((function(i){const a=Date.now();e.addOrUpdateLink(o,t,"ON",a),o.peers[t.location]=1,r&&(t.peers[o.location]=1,e.addOrUpdateLink(t,o,"ON",a)),s(),n.success(i,"")})).error((function(e){n.error(getError(e),"Error connecting masters")})).finally((function(){e.setLoader(!1)}))},e.addOrUpdateLink=function(o,t,r,n){const s=o.location+"|"+t.location;let i=e.linksHash[s];const a=t.location+"|"+o.location,c=e.linksHash[a];return i||(i={},e.linksHash[s]=i,e.links.push(i),i.source=o,i.target=t,e.needsToRestart=!0),i.status=r,i.timestamp=n,i.reversePeerMissing="master"===o.repositoryType&&"master"===t.repositoryType&&!c,c&&c.reversePeerMissing&&(c.reversePeerMissing=!1),e.linksHash[s]=i,e.updateWarnings&&e.updateWarnings(),i},e.deleteLink=function(o,t){e.links.splice(e.links.indexOf(o),1);const r=o.source.location+"|"+o.target.location;if(delete e.linksHash[r],(o.source.disabledReason||o.target.disabledReason)&&(console.log("link to funky node removed, refresh"),e.needsToRefresh=!0),t){const t=o.target.location+"|"+o.source.location,r=e.linksHash[t];r&&e.deleteLink(r,!1)}},e.updateMasterNode=function(o,t,s,i){return p.getMaster(o.name,{params:{masterLocation:r(o)}}).error((function(e){return"The location is unreachable."!==o.disabledReason&&(n.error(getError(e),"Error accessing master "+o.name),o.disabledReason="The location is unreachable.",o.peers={},o.workers={},o.hasWorkers=!1),o.timestamp=t,!0})).success((function(r){o.averageReadTime=r.averageReadTime,o.completedReads=r.completedReads,o.completedWrites=r.completedWrites,o.failedReads=r.failedReads,o.failedWrites=r.failedWrites,o.pendingWrites=r.pendingWrites,o.runningReads=r.runningReads,o.runningWrites=r.runningWrites,o.readonly=r.readonly,o.mode=r.mode,o.nodeID=r.nodeID,o.peers={},o.workers={},o.timestamp=t,o.hasWorkers=r.workers.length>0,r.peers.forEach((function(r){o.peers[r.location]=1,r.location in e.urlToNode||(s?(console.log("master disappeared, refreshing"),e.needsToRefresh=!0):e.urlToNode[r.location]={name:e.getLabel(r.location),disabledReason:"You are not connected to this master's location or the master was deleted",location:r.location,nodeID:r.nodeID,repositoryType:"master",artificiallyAdded:!0}),e.addOrUpdateLink(o,e.urlToNode[r.location],"ON",t)})),r.workers.forEach((function(r){o.workers[r.location]=1;let n={};if(r.location in e.urlToNode)n=e.urlToNode[r.location];else{if(s)return console.log("worker disappeared, refreshing"),void(e.needsToRefresh=!0);n=e.urlToNode[r.location]={name:e.getLabel(r.location),location:r.location,repositoryType:"worker",artificiallyAdded:!0}}n.fingerprint=r.fingerprint,n.averageTaskTime=r.averageTaskTime,n.failedTasks=r.failedTasks,n.completedTasks=r.completedTasks,n.runningTasks=r.runningTasks,n.timestamp=t,n.artificiallyAdded?(n.disabledReason="You are not connected to this worker's location.",r.lastError&&(n.disabledReason+="<br>"+r.lastError)):r.lastError?n.disabledReason=r.lastError:delete n.disabledReason,n.disabledReason&&(n.disabledReason=a.trustAsHtml(n.disabledReason)),n.cluster=n.cluster||[],-1===n.cluster.indexOf(o.cluster)&&n.cluster.push(o.cluster);let c=r.status;i&&(c=["UNINITIALIZED","ON","OFF","REPLICATION_SERVER","REPLICATION_CLIENT","OUT_OF_SYNC","OUT_OF_SYNC_FORCED","WAITING_WRITE","WRITING"][Math.floor(9*Math.random())]),e.addOrUpdateLink(o,e.urlToNode[r.location],c,t)}))})).catch((function(){return!0}))},e.getNodes=function(){return e.nodes=[],e.links=[],e.linksHash={},e.clone={},e.selectedNode=null,e.clusters=[],e.setLoader(!0),f.getCluster().success((function(o){e.hasNodes=o.length>0,e.links=[],e.linksHash={},e.clusters=[];const r=Date.now();e.urlToNode=o.reduce((function(o,t){return"master"!==t.type&&"worker"!==t.type||(o[t.uri]={name:e.getLabel(t.uri),local:t.local,location:t.uri,repositoryType:t.type,timestamp:r}),o}),{});let n=0;const s=Object.keys(e.urlToNode).filter((function(o){return"master"===e.urlToNode[o].repositoryType})).sort((function(e,o){return e<o?-1:e>o?1:0})).map((function(o){const t=e.urlToNode[o];return t.cluster=n,e.clusters.push(t),n++,e.updateMasterNode(t,r)}));return t.all(s).finally((function(){e.nodes=_.sortBy(Object.keys(e.urlToNode).map((function(o){return e.urlToNode[o]})),["name"]),e.render(),e.setLoader(!1)}))})).error((function(o){e.hasNodes=!1,n.error(getError(o),"Error getting nodes"),e.setLoader(!1)})).finally((function(){e.needsToRefresh=!1}))},e.trackAddedOrRemovedNodes=function(o){return f.getCluster().success((function(t){const r=t.reduce((function(e,o){return"master"!==o.type&&"worker"!==o.type||(e[o.uri]={location:o.uri,repositoryType:o.type}),e}),{});for(let t=0;t<e.nodes.length;t++){const n=e.nodes[t];if(n.location in r)n.artificiallyAdded||(n.timestamp=o,delete r[n.location]);else if(!n.artificiallyAdded)return console.log("old node disappeared, refresh"),e.needsToRefresh=!0,!0}Object.keys(r).length>0&&(console.log("new nodes appeared, refresh"),e.needsToRefresh=!0)})).error((function(e){n.error(getError(e),"Error getting nodes")}))},e.updateClusterIfNeeded=function(o){e.updating=!0;const r=Date.now(),n=function(){if(!e.needsToRefresh)for(let o=0;o<e.links.length;o++){const t=e.links[o];t.timestamp!==r&&(console.log("nodes disconnected, removing link"),e.deleteLink(t,!1))}e.needsToRefresh?(console.log("refresh requested"),e.getNodes()):e.needsToRestart?(console.log("only links changed, restarting"),e.restart()):(e.updateStatuses(),e.updateColors(),e.updateWarnings(),e.updating=!1)};if(o)e.trackAddedOrRemovedNodes(r).then((function(){if(e.needsToRefresh)n();else{const o=[];for(let t=0;t<e.nodes.length;t++){const n=e.nodes[t];"master"===n.repositoryType&&o.push(e.updateMasterNode(n,r,!0))}t.all(o).finally(n)}}));else{const o=[];for(let t=0;t<e.nodes.length;t++){const n=e.nodes[t];"master"===n.repositoryType&&o.push(e.updateMasterNode(n,r,!0))}t.all(o).finally(n)}},e.getNodes(),e.setMode=function(o){e.attributeChange=!0,e.setMasterAttribute(e.selectedNode,"Mode",o)},e.setReadonly=function(o){e.attributeChange=!0,e.selectedNode.readonly=o,e.setMasterAttribute(e.selectedNode,"ReadOnly",o)};let g=0;const m=l((function(){e.attributeChange||e.updating||(g++,e.updateClusterIfNeeded(g%3==0))}),2e3);e.$on("$destroy",(function(){l.cancel(m)})),e.attributeChange=!1,e.updating=!1;const y=angular.element(c),k=function(){e.resize()};y.bind("resize",k),e.$on("$destroy",(function(){y.unbind("resize",k)})),e.$on("onToggleNavWidth",(function(){e.resize()}))}function s(e,o,t){e.clone=angular.copy(t),e.ok=function(){const t=new RegExp("^[a-zA-Z0-9-_]+$");e.isInvalidRepoName=!t.test(e.clone.repositoryID),e.isInvalidRepoName||o.close(e.clone)},e.cancel=function(){o.dismiss("cancel")}}angular.module("graphdb.framework.clustermanagement.controllers",["ui.bootstrap","graphdb.framework.core.services.repositories","graphdb.framework.rest.repositories.service","graphdb.framework.rest.cluster.service","toastr"]).controller("ClusterManagementCtrl",n).controller("CloneRepositoryCtrl",s),n.$inject=["$scope","$http","$q","toastr","$repositories","$modal","$sce","$window","$interval","ModalService","$timeout","ClusterRestService","RepositoriesRestService"],s.$inject=["$scope","$modalInstance","clone"]}}]);
//# sourceMappingURL=7.a4a2cbe99f4433279558.bundle.js.map