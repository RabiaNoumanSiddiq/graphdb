{"version":3,"sources":["webpack:///./src/js/angular/rest/connectors.rest.service.js","webpack:///./src/js/angular/externalsync/controllers.js","webpack:///./src/js/angular/core/directives/queryeditor/query-editor.controller.js","webpack:///./src/js/angular/core/directives/queryeditor/query-editor.directive.js"],"names":["angular","module","factory","ConnectorsRestService","$inject","CONNECTORS_ENDPOINT","$http","getConnectors","get","initConnector","prefix","hasConnector","checkConnector","data","post","headers","jsonToFormData","str","Object","keys","forEach","key","push","encodeURIComponent","join","mapCreateValuesToUiValues","values","options","i","length","option","__type","__name","j","__childOptions","child","k","valueK","hasOwnProperty","isDefined","__defaultValue","optionEl","isUndefined","map","_","value","toJson","_evaluateSparqlQuery","http","repository","query","buildNamePrefix","substring","createConnectorQuery","name","fields","reportError","fcopy","sortObject","obj","newObject","each","childOption","copy","arrayMap","reduce","acc","Error","fromJson","e","__label","message","removeEmptyValues","Array","isArray","filter","item","trim","finalString","replace","ConnectorsCtrl","$scope","$repositories","$modal","toastr","ModalService","$q","RDF4JRepositoriesRestService","resetProgress","repair","beingBuiltConnector","percentDone","status","processedEntities","estimatedEntities","indexedEntities","entitiesPerSecond","actionName","waitOnRepairStartOnce","eta","inline","iri","openProgressModal","$","extend","doneCallback","modalInstance","dismiss","open","templateUrl","controller","size","backdrop","scope","executeCreate","connector","errorCallback","modal","addStatements","getActiveRepository","update","then","res","existing","success","err","error","getError","finally","loader","controllers","definitions","getLoaderMessage","timeSeconds","Date","now","loaderStartTime","timeHuman","getHumanReadableSeconds","progressMessage","extraMessage","setLoader","isRunning","canWriteActiveRepo","connectors","all","connectorIris","createStatusQueryForAny","evaluateSparqlQuery","results","bindings","statusObject","JSON","parse","console","parseFirstBuildingResult","d","split","catch","getOptions","isEmpty","isObject","toPrettyJson","$watch","getActiveLocation","copyConnector","newValues","resolve","result","skipConversion","newConnector","inst","type","openSimpleModal","title","warning","delete","isExternal","indexOf","force","namePrefix","deleteConnectorQuery","viewQuery","DeleteConnectorCtrl","$modalInstance","ok","close","cancel","ExtendNewConnectorCtrl","toQuery","label","addField","index","optionName","newField","defaultValues","splice","addOption","array","deleteOption","addMapOption","deleteMapOption","form","$valid","CreateConnectorCtrl","$controller","this","CreateProgressCtrl","$interval","initProgress","statusIri","createStatusQueryForIri","progressInterval","getFirstStatusFromResult","toFixed","etaSeconds","$on","input","Math","ceil","QueryEditorCtrl","$timeout","SparqlRestService","$filter","$window","$jwtAuth","MonitoringRestService","LocalStorageAdapter","LSKeys","defaultTabConfig","id","inference","sameAs","checkQueryIntervalId","principal","getPrincipal","initTabs","appSettings","DEFAULT_INFERENCE","DEFAULT_SAMEAS","skipCountQuery","EXECUTE_COUNT","ignoreSharedQueries","IGNORE_SHARED_QUERIES","tabsData","tabs","TABS_STATE","$watchCollection","newVal","oldVal","saveQueryToLocal","currentQuery","deleteCachedSparqlResults","currentQueryTab","tab","set","noTimer","yasrInnerContainer","element","document","getElementById","queryIsRunning","queryStartTime","countTimeouted","noLoaderTimer","addClass","currentTrackAlias","abortRequested","removeClass","$$phase","$apply","fixSizesOnHorizontalViewModeSwitch","verticalView","visibleWindowHeight","window","innerHeight","documentElement","clientHeight","body","orientationViewMode","viewMode","newHeight","querySelector","getBoundingClientRect","style","height","noPadding","minHeight","paddingRight","paddingLeft","editor","timer","yasr","container","resize","showHideEditor","foo","params","newRepo","yasrData","undefined","queryType","resultsCount","allResultsCount","sizeDelta","errorMessage","repositoryError","selectTab","runQuery","changePage","explain","executedQueryTab","getQueryType","isActiveRepoOntopType","explainRequested","currentTabConfig","resetCurrentTabConfig","lastRunQueryMode","getQueryMode","toggleSampleQueries","showSampleQueries","getSavedQueries","sampleQueries","collapse","width","msg","getExistingTabId","existingTabId","showModal","modalSelector","shared","savedQuery","getValue","findTabIndexByID","currentScope","hint","createElement","innerHTML","fontSize","color","backgroundColor","position","zIndex","newValue","elRect","appendChild","top","left","right","offsetWidth","parentNode","removeChild","pageSize","page","queryExists","saveTab","idx","loadTab","setValue","updateDownloadDropdown","$broadcast","output","outputType","customError","getException","setYasrResponse","textStatus","jqXhrOrErrorString","hasClass","click","TABS_STATE_CURRENT_ID","offset","allResultsCountExact","timeFinished","timeTook","customUpdateMessage","warningMessage","css","setInterval","showOrHideSaveAsDropDown","isOntop","isFedX","isActiveRepoFedXType","sameAsBtn","inferenceBtn","disabled","handleSameAsAndInferenceBtns","nocount","overrideSameAsInferenceAndNoCountIfNeeded","addNewTab","callback","tabName","isTabChangeOk","maxID","newID","newTab","TABS_STATE_MAXID","callbackArgs","prototype","slice","call","arguments","apply","abortCurrentQuery","abortQueryByAlias","editQuery","edit","okButtonText","queryModal","addNewSavedQuery","deleteQueryHttp","editSavedQuery","getNamespaces","namespacesLoading","getRepositoryNamespaces","usedPrefixes","namespace","namespaces","changePagination","addKnownPrefixes","stringify","querySelected","tabId","highlightNextTabChange","deleteQuery","savedQueryName","deleteSavedQuery","saveQuery","saveQueryHttp","changeViewMode","VIEW_MODE","focusQueryEditor","find","is","focus","getActiveRepositoryNoError","onbeforeunload","clearInterval","mouseup","event","target","has","getQueryID","attr","$saveAsDropDown","queryValid","header","remove","isNew","info","tabEvent","relatedTarget","colors","times","highlightFun","editQueryModal","deleteQueryModal","saveQueryModal","getResultsDescription","desc","currentPageEnd","min","getUpdateDescription","abs","getStaleWarningMessage","secondsAgo","round","bind","unbind","QuerySampleModalCtrl","queryEditorDirective","$location","callbackOnChange","restrict","link","attrs","nostorage","notabs","notoolbar","notoolbarSaved","notoolbarCopy","notoolbarInference","notoolbarSameAs","nostatus","norun","runButtonName","saveQueryAction","runQueryAction","explainQueryAction","goToNextTabAction","goToPreviousTabAction","requestedTab","first","fromTextArea","persistent","indentUnit","createShareLink","cursorHeight","sparql","showQueryButton","acceptHeaderGraph","acceptHeaderSelect","extraKeys","toastBuildIndex","allowHtml","toastError","on","clearTimeout","changesTimeout","hasError","setTimeout","toggleClass","hide","afterCopy","blur","originalExecuteQuery","executeQuery","originalGetUrlArguments","getUrlArguments","createCustomError","statusText","responseText","connectorProgressModal","drawButtons","yasqe","buttons","config","qType","cm","resultsContainer","empty","performance","endpoint","args","thisTabConfig","thisTabId","handlers","countCallback","dataOrJqXhr","setResultsCount","allCount","getTime","setQueryLimit","getValueWithoutComments","doExecute","getRepositorySize","repoSize","parseInt","command","hasSupport","connectorName","pluginName","setNewTabState","progressScope","$new","originalGetAjaxConfig","getAjaxConfig","getResponseHeader","contentType","response","executedQueryTabIdx","queryResultState","toBoolean","v","loadQueryIntoExistingOrNewTab","infer","onHandler","search","execute","addTabWithQueryIfNeeded","owner","getSavedQuery","updateRepositoryAndSecurity","signal","getAuthToken","callbackOrConfig","copyToClipboardQuery","openCopyToClipboardModal","url","location","protocol","host","pathname","param","createQueryURL","copyToClipboardResult","resultURI","goToVisual","paramsToParse","path","getUsedPrefixes","persistency","getQueryResultsAsFormat","downloadFormat","$wbDownload","val","auth","localStorage","getItem","submit","complete","setNewTabStateForThis","updateResultsCallback","repoSizeDiff","Number","responseJSON","max","resetResults","setResponse","drawQueryEditor","directive"],"mappings":"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","file":"10.a1beb5a39f13b1df6fab.bundle.js","sourcesContent":["angular\n    .module('graphdb.framework.rest.connectors.service', [])\n    .factory('ConnectorsRestService', ConnectorsRestService);\n\nConnectorsRestService.$inject = ['$http'];\n\nconst CONNECTORS_ENDPOINT = 'rest/connectors';\n\nfunction ConnectorsRestService($http) {\n\n    return {\n        getConnectors,\n        initConnector,\n        hasConnector,\n        checkConnector\n    };\n\n    function getConnectors() {\n        return $http.get(CONNECTORS_ENDPOINT);\n    }\n\n    function initConnector(prefix) {\n        return $http.get(`${CONNECTORS_ENDPOINT}/options?prefix=${prefix}`);\n    }\n\n    function hasConnector(prefix) {\n        return $http.get(`${CONNECTORS_ENDPOINT}/existing?prefix=${prefix}`);\n    }\n\n    function checkConnector(data) {\n        return $http.post(`${CONNECTORS_ENDPOINT}/check`, data, {\n            headers: {\n                'Content-Type': 'text/plain'\n            }\n        });\n    }\n}\n","import 'angular/rest/rdf4j.repositories.rest.service';\nimport 'angular/rest/connectors.rest.service';\n\nconst modules = [\n    'graphdb.framework.rest.rdf4j.repositories.service',\n    'graphdb.framework.rest.connectors.service'\n];\n\nangular\n    .module('graphdb.framework.externalsync.controllers', modules)\n    .controller('ConnectorsCtrl', ConnectorsCtrl)\n    .controller('ExtendNewConnectorCtrl', ExtendNewConnectorCtrl)\n    .controller('CreateConnectorCtrl', CreateConnectorCtrl)\n    .controller('CreateProgressCtrl', CreateProgressCtrl)\n    .controller('DeleteConnectorCtrl', DeleteConnectorCtrl)\n    .filter('ceil', ceil);\n\nfunction jsonToFormData(data) {\n    const str = [];\n    Object.keys(data).forEach(function (key) {\n        str.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));\n    });\n    return str.join('&');\n}\n\nfunction toArrayMap(map) {\n    return _.map(map, function (value, key) {\n        return {key: key, value: value};\n    });\n}\n\nfunction fromArrayMap(arrayMap) {\n    return _.reduce(arrayMap, function (acc, value) {\n        if (value.key === '' && value.value === '') {\n            // empty pair, skip it\n        } else if (value.key === '') {\n            throw new Error('Key may not be empty with value \"' + value.value + '\"');\n        } else if (acc.hasOwnProperty(value.key)) {\n            throw new Error('Duplicate key ' + value.key);\n        } else {\n            acc[value.key] = value.value;\n        }\n        return acc;\n    }, {});\n}\n\nfunction mapCreateValuesToUiValues(values, options) {\n    for (let i = 0; i < options.length; i++) {\n        const option = options[i];\n        if (option.__type === 'StringArray') {\n            if (!values[option.__name]) {\n                values[option.__name] = [''];\n            }\n        } else if (option.__type === 'OptionArray') {\n            if (!values[option.__name]) { // values has no entry for this option\n                values[option.__name] = [];\n                const optionEl = {};\n                for (let j = 0; j < option.__childOptions.length; j++) {\n                    const child = option.__childOptions[j];\n                    if (child.__type === 'StringArray') {\n                        optionEl[child.__name] = [''];\n                    } else {\n                        optionEl[child.__name] = (!angular.isUndefined(child.__defaultValue) ? child.__defaultValue : '');\n                    }\n                }\n                values[option.__name].push(optionEl);\n            } else { // values already has en entry for this option\n                // Copies the default value for Boolean child options if no explicit value is set\n                for (let j = 0; j < option.__childOptions.length; j++) {\n                    const child = option.__childOptions[j];\n                    if (child.__type === 'Boolean') {\n                        for (let k = 0; k < values[option.__name].length; k++) {\n                            const valueK = values[option.__name][k];\n                            if (!valueK.hasOwnProperty([child.__name]) && angular.isDefined(child.__defaultValue)) {\n                                valueK[child.__name] = child.__defaultValue;\n                            }\n                        }\n                    }\n                }\n            }\n        } else if (option.__type === 'Map') {\n            if (!values[option.__name]) {\n                values[option.__name] = [];\n            } else {\n                values[option.__name] = toArrayMap(values[option.__name]);\n            }\n        } else if (option.__type === 'JsonString') {\n            if (values[option.__name]) {\n                values[option.__name] = angular.toJson(values[option.__name], 2);\n            }\n        } else {\n            if (angular.isUndefined(values[option.__name])) {\n                values[option.__name] = (!angular.isUndefined(option.__defaultValue) ? option.__defaultValue : '');\n            }\n        }\n    }\n\n    return values;\n}\n\nfunction _evaluateSparqlQuery(http, repository, query) {\n    return http.post('repositories/' + repository, jsonToFormData({query: query}),\n        {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Accept': 'application/sparql-results+json',\n                'X-GraphDB-Local-Consistency': 'updating'\n            }\n        });\n}\n\nfunction buildNamePrefix(prefix) {\n    return prefix.substring(0, prefix.length - 1) + '/instance#';\n}\n\nfunction createConnectorQuery(name, prefix, fields, options, reportError) {\n    // Returns a copy of the parameter obj sorted according to the order in options\n    function sortObject(obj, options) {\n        const newObject = {};\n        _.each(options, function (option) {\n            if (angular.isDefined(obj[option.__name])) {\n                if (option.__type === 'OptionArray') {\n                    newObject[option.__name] = [];\n                    _.each(obj[option.__name], function (childOption) {\n                        newObject[option.__name].push(sortObject(childOption, option.__childOptions));\n                    });\n                } else {\n                    newObject[option.__name] = angular.copy(obj[option.__name]);\n                }\n            }\n        });\n        return newObject;\n    }\n\n    const fcopy = sortObject(fields, options);\n\n    for (let i = 0; i < options.length; i++) {\n        try {\n            if (options[i].__type === 'Map') {\n                fcopy[options[i].__name] = fromArrayMap(fcopy[options[i].__name]);\n            } else if (options[i].__type === 'JsonString') {\n                fcopy[options[i].__name] = angular.fromJson(fcopy[options[i].__name]);\n            }\n        } catch (e) {\n            reportError(options[i].__label, e.message);\n            return null;\n        }\n    }\n\n    removeEmptyValues(fcopy);\n    //escapeValues(fields);\n    let finalString = '';\n    finalString += 'PREFIX :<' + prefix + '>\\n';\n    const namePrefix = buildNamePrefix(prefix);\n    finalString += 'PREFIX inst:<' + namePrefix + '>\\n';\n    finalString += 'INSERT DATA {\\n';\n    finalString += \"\\tinst:\" + name + \" :createConnector '''\\n\"; // eslint-disable-line quotes\n    finalString += angular.toJson(fcopy, 2);\n    finalString += \"\\n''' .\\n}\\n\"; // eslint-disable-line quotes\n    finalString = finalString.replace(/\\\\/g, '\\\\\\\\\\\\');\n    return finalString;\n}\n\nfunction createStatusQueryForIri(iri) {\n    const statusIri = iri.replace(/\\/instance#.+$/, '#connectorStatus');\n    let finalString = '';\n    finalString += 'SELECT ?status {\\n';\n    finalString += '\\t<' + iri + '> <' + statusIri + '> ?status';\n    finalString += '\\n}';\n    return finalString;\n}\n\nfunction createStatusQueryForAny(connectors) {\n    const connectorIris = _.map(connectors,\n        function (k) {\n            return '<' + k.value + 'connectorStatus' + '>';\n        }).join('|');\n\n    if (connectorIris) {\n        return 'SELECT ?connector ?status { ?connector ' + connectorIris + ' ?status }';\n    }\n\n    return null;\n}\n\nfunction repairConnectorQuery(name, prefix) {\n    const namePrefix = buildNamePrefix(prefix);\n    return 'PREFIX prefix:<' + prefix + '>\\n' +\n        'INSERT DATA {\\n' +\n        '\\t<' + namePrefix + name + '> prefix:repairConnector \"\"\\n' +\n        '}';\n}\n\nfunction deleteConnectorQuery(name, prefix, force) {\n    const namePrefix = prefix.substring(0, prefix.length - 1) + \"/instance#\";\n    return 'PREFIX prefix:<' + prefix + '>\\n' +\n        'INSERT DATA {\\n' +\n        '\\t<' + namePrefix + name + '> prefix:dropConnector \"' + (force ? \"force\" : \"\") + '\"\\n' +\n        '}';\n}\n\nfunction removeEmptyValues(data) {\n    // remove empty values from array\n    if (Array.isArray(data)) {\n        data = _.filter(data, function (item) {\n            return item !== null && (!item.trim || item.trim() !== '');\n        });\n    }\n    // remove empty values from object values\n    Object.keys(data).forEach(function (key) {\n        if ((data[key] === '' || data[key] == null) && data[key] !== false) {\n            delete data[key];\n        } else if (typeof data[key] === 'object') {\n            data[key] = removeEmptyValues(data[key]);\n        }\n    });\n    return data;\n}\n\nfunction parseFirstBuildingResult(results) {\n    if (results.bindings) {\n        for (let i = 0; i < results.bindings.length; i++) {\n            try {\n                const statusObject = JSON.parse(results.bindings[i].status.value);\n                if (statusObject.status === 'BUILDING') {\n                    return {\n                        connector: results.bindings[i].connector.value,\n                        status: statusObject\n                    };\n                }\n            } catch (e) {\n                console.error(e); // eslint-disable-line no-console\n            }\n        }\n    }\n\n    return {};\n}\n\nConnectorsCtrl.$inject = ['$scope', '$http', '$repositories', '$modal', 'toastr', 'ModalService', '$q', 'RDF4JRepositoriesRestService', 'ConnectorsRestService'];\n\nfunction ConnectorsCtrl($scope, $http, $repositories, $modal, toastr, ModalService, $q, RDF4JRepositoriesRestService, ConnectorsRestService) {\n    $scope.loader = false;\n\n    $scope.controllers = [];\n\n    $scope.existing = {};\n\n    $scope.definitions = {};\n\n    $scope.getLoaderMessage = function () {\n        const timeSeconds = (Date.now() - $scope.loaderStartTime) / 1000;\n        const timeHuman = $scope.getHumanReadableSeconds(timeSeconds);\n        let message = '';\n        if ($scope.progressMessage) {\n            message = $scope.progressMessage + '... ' + timeHuman;\n        } else {\n            message = 'Running operation...' + timeHuman;\n        }\n        if ($scope.extraMessage && timeSeconds > 10) {\n            message += '\\n' + $scope.extraMessage;\n        }\n\n        return message;\n    };\n\n    $scope.setLoader = function (isRunning, progressMessage, extraMessage) {\n        if (isRunning) {\n            $scope.loader = true;\n            $scope.loaderStartTime = Date.now();\n            $scope.progressMessage = progressMessage;\n            $scope.extraMessage = extraMessage;\n        } else {\n            $scope.loader = false;\n            $scope.progressMessage = '';\n            $scope.extraMessage = '';\n        }\n    };\n\n    $scope.initConnector = function (connector) {\n        return ConnectorsRestService.initConnector(encodeURIComponent(connector.value))\n            .then(function (res) {\n                $scope.definitions[connector.key] = res.data;\n\n                return ConnectorsRestService.hasConnector(encodeURIComponent(connector.value))\n                    .then(function (res) {\n                        $scope.existing[connector.key] = res.data;\n\n                    });\n            });\n    };\n\n    $scope.getConnectors = function () {\n        if (!$scope.canWriteActiveRepo()) {\n            return;\n        }\n\n        $scope.setLoader(true, 'Fetching connectors', 'Normally this is a fast operation but it may take longer if a bigger repository needs to be initialised first.');\n\n        ConnectorsRestService.getConnectors()\n            .then(function (res) {\n                $scope.connectors = Object.keys(res.data).map(function (key) {\n                    return {key: key, value: res.data[key]};\n                });\n\n                $q.all(_.map($scope.connectors, function (connector) {\n                    return $scope.initConnector(connector);\n                })).finally(function () {\n                    resetProgress();\n\n                    const query = createStatusQueryForAny($scope.connectors);\n\n                    if (query) {\n                        evaluateSparqlQuery(query)\n                            .then(function (res) {\n                                const status = parseFirstBuildingResult(res.data.results);\n                                if (status.connector) {\n                                    // has a building connector, open progress indicator\n                                    const d = status.connector.split(/#/);\n                                    d[0] = d[0].replace(/\\/instance$/, '#');\n                                    showProgress(d[0], d[1]);\n                                }\n                            })\n                            .finally(function () {\n                                $scope.setLoader(false);\n                            });\n                    } else {\n                        $scope.setLoader(false);\n                    }\n                });\n            }).catch(function (e) {\n                $scope.setLoader(false);\n                toastr.error(getError(e), 'Could not get connectors');\n            });\n\n        $scope.existing = {};\n    };\n\n    $scope.getOptions = function (connector) {\n        return $scope.definitions[connector.key];\n    };\n\n    $scope.isEmpty = function (value) {\n        return angular.isObject(value) && Object.keys(value).length === 0;\n    };\n\n    $scope.toPrettyJson = function (value) {\n        return angular.toJson(value, 2);\n    };\n\n    $scope.$watch(function () {\n        return $repositories.getActiveRepository();\n    }, $scope.getConnectors);\n\n    $scope.$watch(function () {\n        return $repositories.getActiveLocation();\n    }, $scope.getConnectors);\n\n    function evaluateSparqlQuery(query) {\n        return _evaluateSparqlQuery($http, $repositories.getActiveRepository(), query);\n    }\n\n    function resetProgress(repair) {\n        $scope.beingBuiltConnector = {\n            percentDone: 0,\n            status: {\n                processedEntities: 0,\n                estimatedEntities: 0,\n                indexedEntities: 0,\n                entitiesPerSecond: 0\n            },\n            actionName: repair ? 'Repairing' : 'Creating',\n            waitOnRepairStartOnce: !!repair,\n            eta: '-',\n            inline: false,\n            iri: null\n        };\n    }\n\n    function openProgressModal(prefix, name, repair) {\n        resetProgress(repair);\n\n        $.extend($scope.beingBuiltConnector, {\n            iri: buildNamePrefix(prefix) + name,\n            name: name,\n            inline: false,\n            doneCallback: function () {\n                $scope.beingBuiltConnector.modalInstance.dismiss('cancel');\n            }\n        });\n\n        $scope.beingBuiltConnector.modalInstance = $modal.open({\n            templateUrl: 'pages/connectorProgress.html',\n            controller: 'CreateProgressCtrl',\n            size: 'lg',\n            backdrop: 'static',\n            scope: $scope\n        });\n\n        return $scope.beingBuiltConnector.modalInstance;\n    }\n\n    function showProgress(prefix, name) {\n        resetProgress();\n\n        $.extend($scope.beingBuiltConnector, {\n            iri: buildNamePrefix(prefix) + name,\n            name: name,\n            inline: true,\n            doneCallback: function () {\n                $scope.beingBuiltConnector.inline = false;\n            }\n        });\n    }\n\n    function executeCreate(connector, obj, errorCallback) {\n        const modal = openProgressModal(connector.value, obj.name, false);\n        RDF4JRepositoriesRestService.addStatements($repositories.getActiveRepository(), jsonToFormData({update: obj.query}))\n            .then(function () {\n                ConnectorsRestService.getConnectors().then(function () {\n                    ConnectorsRestService.hasConnector(encodeURIComponent(connector.value)).then(function (res) {\n                        $scope.existing[connector.key] = res.data;\n                    });\n                });\n                toastr.success('Created connector ' + obj.name);\n            }, function (err) {\n                toastr.error(getError(err));\n                errorCallback();\n            }).finally(function () {\n                modal.dismiss('cancel');\n            });\n    }\n\n    $scope.copyConnector = function (connector, values) {\n        let newValues;\n        if (!angular.isUndefined(values)) {\n            newValues = angular.copy(values);\n            newValues.name = newValues.name + '-copy';\n        }\n        const modal = $modal.open({\n            templateUrl: 'pages/createConnector.html',\n            controller: 'CreateConnectorCtrl',\n            size: 'lg',\n            backdrop: 'static',\n            resolve: {\n                connector: function () {\n                    return connector;\n                },\n                values: function () {\n                    return angular.isUndefined(newValues) ? {name: '', values: {}} : newValues;\n                },\n                options: function () {\n                    return $scope.getOptions(connector);\n                }\n            }\n        });\n\n        modal.result.then(function (obj) {\n            executeCreate(connector, obj, function () {\n                obj.skipConversion = true;\n                $scope.newConnector(connector, obj);\n            });\n        });\n    };\n\n    $scope.newConnector = function (connector, values) {\n        const modal = $modal.open({\n            templateUrl: 'pages/createConnector.html',\n            controller: 'CreateConnectorCtrl',\n            size: 'lg',\n            backdrop: 'static',\n            resolve: {\n                connector: function () {\n                    return connector;\n                },\n                values: function () {\n                    return angular.isUndefined(values) ? {name: '', values: {}} : values;\n                },\n                options: function () {\n                    return $scope.getOptions(connector);\n                }\n            }\n        });\n\n        modal.result.then(function (obj) {\n            executeCreate(connector, obj, function () {\n                obj.skipConversion = true;\n                $scope.newConnector(connector, obj);\n            });\n        });\n    };\n\n    $scope.repair = function (inst, type) {\n        ModalService.openSimpleModal({\n            title: 'Confirm repair',\n            message: 'Are you sure you want to repair this connector?<br>Note that repair means delete + recreate with the same settings.',\n            warning: true\n        }).result\n            .then(function () {\n                const modal = openProgressModal(type.value, inst.name, true);\n\n                const query = repairConnectorQuery(inst.name, type.value);\n\n                RDF4JRepositoriesRestService.addStatements($repositories.getActiveRepository(), jsonToFormData({update: query}))\n                    .then(function () {\n                        ConnectorsRestService.getConnectors().then(function () {\n                            ConnectorsRestService.hasConnector(encodeURIComponent(type.value)).then(function (res) {\n                                $scope.existing[type.key] = res.data;\n                            });\n                        });\n                        toastr.success('Repaired connector ' + inst.name);\n                    }, function (err) {\n                        toastr.error(getError(err));\n                    }).finally(function () {\n                        modal.dismiss('cancel');\n                    });\n            });\n    };\n\n    $scope.delete = function (inst, type) {\n        const isExternal = type.key.indexOf(\"Elastic\") >= 0 || type.key.indexOf(\"Solr\") >= 0;\n\n        $modal.open({\n            templateUrl: 'js/angular/externalsync/templates/deleteConnector.html',\n            controller: 'DeleteConnectorCtrl',\n            resolve: {\n                type: function () {\n                    return type.key;\n                },\n                isExternal: function () {\n                    return isExternal;\n                }\n            }\n        }).result\n            .then(function(force) {\n                $scope.setLoader(true, 'Deleting connector ' + inst.name, 'This is usually a fast operation but it might take a while.');\n\n                const query = deleteConnectorQuery(inst.name, type.value, force);\n                RDF4JRepositoriesRestService.addStatements($repositories.getActiveRepository(), jsonToFormData({update: query}))\n                    .then(function () {\n                        ConnectorsRestService.getConnectors().then(function () {\n                            ConnectorsRestService.hasConnector(encodeURIComponent(type.value)).then(function (res) {\n                                $scope.existing[type.key] = res.data;\n                            });\n                        });\n                        if (force) {\n                            toastr.success(\"Deleted (with force) connector \" + inst.name);\n                            if (isExternal) {\n                                toastr.warning(\"You may have to remove the index manually from \" + type.key);\n                            }\n                        } else {\n                            toastr.success(\"Deleted connector \" + inst.name);\n                        }\n                    }, function (err) {\n                        toastr.error(getError(err));\n                    }).finally(function() {\n                        $scope.setLoader(false);\n                    });\n            });\n    };\n\n    $scope.viewQuery = function (connector, inst) {\n        $modal.open({\n            templateUrl: 'pages/viewQuery.html',\n            controller: 'ViewQueryCtrl',\n            resolve: {\n                query: function () {\n                    const options = $scope.getOptions(connector);\n                    return createConnectorQuery(inst.name, connector.value,\n                        mapCreateValuesToUiValues(inst.values, options), options);\n                }\n            }\n        });\n    };\n}\n\nDeleteConnectorCtrl.$inject = ['$scope', '$modalInstance', 'type', 'isExternal'];\nfunction DeleteConnectorCtrl($scope, $modalInstance, type, isExternal) {\n    $scope.force = false;\n    $scope.type = type;\n    $scope.isExternal = isExternal;\n\n    $scope.ok = function () {\n        $modalInstance.close($scope.force);\n    };\n\n    $scope.cancel = function () {\n        $modalInstance.dismiss();\n    };\n}\n\nExtendNewConnectorCtrl.$inject = ['$scope', '$modalInstance', 'connector', '$modal', 'toastr'];\nfunction ExtendNewConnectorCtrl($scope, $modalInstance, connector, $modal, toastr) {\n\n    $scope.connector = connector;\n\n    $scope.addField = function (index, optionName) {\n        const newField = angular.copy($scope.defaultValues[optionName][0]);\n        $scope.values[optionName].splice(index + 1, 0, newField);\n    };\n\n    $scope.addOption = function (index, array) {\n        array.splice(index + 1, 0, '');\n    };\n\n    $scope.deleteOption = function (index, array) {\n        array.splice(index, 1);\n    };\n\n    $scope.addMapOption = function (index, array) {\n        array.splice(index + 1, 0, {key: '', value: ''});\n    };\n\n    $scope.deleteMapOption = function (index, array) {\n        array.splice(index, 1);\n    };\n\n    function toQuery() {\n        return createConnectorQuery($scope.name, connector.value, $scope.values, $scope.options,\n            function (label, error) {\n                toastr.error(error, label);\n            });\n    }\n\n    $scope.ok = function () {\n        if ($scope.form.$valid) {\n            const query = toQuery();\n\n            if (query) {\n                $modalInstance.close({name: $scope.name, values: $scope.values, options: $scope.options, query: query});\n            }\n        }\n    };\n\n    $scope.viewQuery = function () {\n        const query = toQuery();\n\n        if (query) {\n            $modal.open({\n                templateUrl: 'pages/viewQuery.html',\n                controller: 'ViewQueryCtrl',\n                resolve: {\n                    query: function () {\n                        return query;\n                    }\n                }\n            });\n        }\n    };\n\n    $scope.cancel = function () {\n        $modalInstance.dismiss('cancel');\n    };\n}\n\nCreateConnectorCtrl.$inject = ['$scope', '$controller', '$http', '$modalInstance', 'connector', '$modal', 'values', 'options'];\n\nfunction CreateConnectorCtrl($scope, $controller, $http, $modalInstance, connector, $modal, values, options) {\n    angular.extend(this, $controller('ExtendNewConnectorCtrl', {\n        $scope: $scope,\n        $modalInstance: $modalInstance,\n        connector: connector,\n        $modal: $modal\n    }));\n    $scope.values = values.values;\n    $scope.options = options;\n    $scope.name = values.name;\n    if (!values.skipConversion) {\n        $scope.values = mapCreateValuesToUiValues($scope.values, $scope.options);\n    }\n    $scope.defaultValues = angular.copy($scope.values);\n}\n\n// Note that this is a fancy controller: it's used both for a modal and for a directive.\n// This means you can't rely on custom injection through resolve in the modal and the scope\n// must be shared with the main connectors controller.\nCreateProgressCtrl.$inject = ['$scope', '$interval', '$http', '$repositories'];\n\nfunction CreateProgressCtrl($scope, $interval, $http, $repositories) {\n    function evaluateSparqlQuery(query) {\n        return _evaluateSparqlQuery($http, $repositories.getActiveRepository(), query);\n    }\n\n    function initProgress() {\n        const query = createStatusQueryForIri($scope.beingBuiltConnector.iri);\n\n        // reset iri value so that watch will fire again when we do something with the same connector\n        $scope.beingBuiltConnector.iri = null;\n\n        $scope.progressInterval = $interval(function () {\n            function getFirstStatusFromResult(results) {\n                if (results.bindings) {\n                    if (results.bindings.length > 0) {\n                        try {\n                            return JSON.parse(results.bindings[0].status.value);\n                        } catch (e) {\n                            console.error(e); // eslint-disable-line no-console\n                        }\n                    }\n                }\n\n                return {};\n            }\n\n            evaluateSparqlQuery(query)\n                .then(function (res) {\n                    const status = getFirstStatusFromResult(res.data.results);\n                    if (status.status === 'BUILDING') {\n                        $scope.beingBuiltConnector.status = status;\n                        $scope.beingBuiltConnector.percentDone = (100 * status.processedEntities / status.estimatedEntities).toFixed(0);\n                        $scope.beingBuiltConnector.eta = $scope.getHumanReadableSeconds(status.etaSeconds);\n                        $scope.beingBuiltConnector.actionName = status.repair ? 'Repairing' : 'Creating';\n                        $scope.beingBuiltConnector.waitOnRepairStartOnce = false;\n                    } else if (status.status === 'BUILT' && !$scope.beingBuiltConnector.waitOnRepairStartOnce) {\n                        // done\n                        $interval.cancel($scope.progressInterval);\n                        if ($scope.beingBuiltConnector.doneCallback) {\n                            $scope.beingBuiltConnector.doneCallback();\n                        }\n                    }\n                });\n        }, 1000);\n\n        $scope.$on('$destroy', function () {\n            $interval.cancel($scope.progressInterval);\n        });\n    }\n\n    $scope.beingBuiltConnector = $scope.beingBuiltConnector || {};\n\n    // for modal instance we get the iri before hand and can start progress now\n    if (!$scope.beingBuiltConnector.inline && $scope.beingBuiltConnector.iri) {\n        initProgress();\n    }\n\n    // for inline progress we need to watch for the iri value\n    $scope.$watch('beingBuiltConnector.iri', function (value) {\n        if ($scope.beingBuiltConnector.inline && value) {\n            initProgress();\n        }\n    });\n}\n\nfunction ceil() {\n    return function (input) {\n        return Math.ceil(input);\n    };\n}\n","import 'angular/utils/local-storage-adapter';\nimport 'angular/rest/sparql.rest.service';\n\nangular\n    .module('graphdb.framework.core.directives.queryeditor.controllers', [\n        'graphdb.framework.utils.localstorageadapter',\n        'graphdb.framework.rest.sparql.service'\n    ])\n    .controller('QueryEditorCtrl', QueryEditorCtrl)\n    .controller('QuerySampleModalCtrl', QuerySampleModalCtrl);\n\nQueryEditorCtrl.$inject = ['$scope', '$timeout', 'toastr', '$repositories', '$modal', 'ModalService', 'SparqlRestService', '$filter', '$window', '$jwtAuth', 'RDF4JRepositoriesRestService', 'MonitoringRestService', 'LocalStorageAdapter', 'LSKeys'];\n\nfunction QueryEditorCtrl($scope, $timeout, toastr, $repositories, $modal, ModalService, SparqlRestService, $filter, $window, $jwtAuth, RDF4JRepositoriesRestService, MonitoringRestService, LocalStorageAdapter, LSKeys) {\n    const defaultTabConfig = {\n        id: \"1\",\n        name: '',\n        query: 'select * where { \\n' +\n        '\\t?s ?p ?o .\\n' +\n        '} limit 100 \\n',\n        inference: true,\n        sameAs: true\n    };\n\n    let principal = $jwtAuth.getPrincipal();\n    let checkQueryIntervalId;\n    if (principal) {\n        initTabs($scope, principal);\n        // principal is not yet set, wait for its initialization\n    } else {\n        $scope.$on('securityInit', function (scope) {\n            principal = $jwtAuth.getPrincipal();\n            initTabs(scope.currentScope, principal);\n        });\n    }\n\n    function initTabs(scope, principal) {\n        defaultTabConfig.inference = principal.appSettings.DEFAULT_INFERENCE;\n        defaultTabConfig.sameAs = principal.appSettings.DEFAULT_SAMEAS;\n\n        scope.skipCountQuery = !principal.appSettings.EXECUTE_COUNT;\n        scope.ignoreSharedQueries = principal.appSettings.IGNORE_SHARED_QUERIES;\n        scope.tabsData = scope.tabs = LocalStorageAdapter.get(LSKeys.TABS_STATE) || [defaultTabConfig];\n\n        scope.$watchCollection('[currentQuery.inference, currentQuery.sameAs]', function (newVal, oldVal, scope) {\n            saveQueryToLocal(scope.currentQuery);\n        });\n\n        scope.$on('repositoryIsSet', deleteCachedSparqlResults);\n    }\n\n    this.hint =  document.createElement(\"span\");\n    this.hint.innerHTML = \"Hint: \\\"abC\\\" matches \\\"abC*\\\", \\\"ab c*\\\" and \\\"ab-c*\\\"\";\n    this.hint.style.fontSize = \"12px\";\n    this.hint.style.color = \"gray\";\n    this.hint.style.backgroundColor = \"white\";\n    this.hint.style.position = \"absolute\";\n    this.hint.style.zIndex = \"3\";\n    this.hint.style.paddingLeft = 12 + \"px\";\n\n    $scope.$watch(function() {\n        return angular.element('.CodeMirror-hints').length;\n    }, (newValue) => {\n        if (newValue) {\n            const elRect = angular.element('.CodeMirror-hints')[0].getBoundingClientRect();\n            document.body.appendChild(this.hint);\n            this.hint.style.top = elRect.top - 20 + \"px\";\n            this.hint.style.left = elRect.right - this.hint.offsetWidth - 12 +  \"px\";\n        } else {\n            this.hint && this.hint.parentNode && this.hint.parentNode.removeChild(this.hint);\n        }\n    });\n\n    $scope.resetCurrentTabConfig = function () {\n        $scope.currentTabConfig = {\n            pageSize: 1000,\n            page: 1,\n            allResultsCount: 0,\n            resultsCount: 0\n        };\n    };\n\n    $scope.queryExists = false;\n\n    $scope.resetCurrentTabConfig();\n\n    // query tab operations\n    $scope.saveTab = saveTab;\n    $scope.loadTab = loadTab;\n    $scope.addNewTab = addNewTab;\n    $scope.isTabChangeOk = isTabChangeOk;\n\n    // query operations\n    $scope.runQuery = runQuery;\n    $scope.abortCurrentQuery = abortCurrentQuery;\n    $scope.editQuery = editQuery;\n    $scope.getNamespaces = getNamespaces;\n    $scope.changePagination = changePagination;\n    $scope.toggleSampleQueries = toggleSampleQueries;\n    $scope.addKnownPrefixes = addKnownPrefixes;\n    $scope.getExistingTabId = getExistingTabId;\n    $scope.querySelected = querySelected;\n    $scope.deleteQuery = deleteQuery;\n    $scope.deleteQueryHttp = deleteQueryHttp;\n    $scope.saveQuery = saveQuery;\n    $scope.saveQueryHttp = saveQueryHttp;\n    $scope.saveQueryToLocal = saveQueryToLocal;\n\n    $scope.setLoader = setLoader;\n    $scope.getLoaderMessage = getLoaderMessage;\n\n    // query editor and results orientation\n    $scope.fixSizesOnHorizontalViewModeSwitch = fixSizesOnHorizontalViewModeSwitch;\n    $scope.changeViewMode = changeViewMode;\n    $scope.showHideEditor = showHideEditor;\n    $scope.focusQueryEditor = focusQueryEditor;\n    $scope.orientationViewMode = LocalStorageAdapter.get(LSKeys.VIEW_MODE) ? LocalStorageAdapter.get(LSKeys.VIEW_MODE) === \"true\" : true;\n    $scope.viewMode = 'none';\n\n    // start of repository actions\n    // FIXME: do we need this??\n    // $scope.getActiveRepository();\n    $scope.getActiveRepository = function () {\n        // same as getActiveRepository() but takes into account repo errors\n        return $repositories.getActiveRepository();\n    };\n\n    $scope.getActiveRepositoryNoError = function () {\n        if (!$scope.repositoryError) {\n            return $repositories.getActiveRepository();\n        }\n    };\n\n    function saveQueryToLocal(currentQueryTab) {\n        $scope.tabs.forEach(function (tab, index) {\n            if (tab.id === currentQueryTab.id) {\n                $scope.tabs[index].query = currentQueryTab.query;\n                $scope.tabs[index].inference = currentQueryTab.inference;\n                $scope.tabs[index].sameAs = currentQueryTab.sameAs;\n            }\n        });\n        LocalStorageAdapter.set(LSKeys.TABS_STATE, $scope.tabs);\n    }\n\n    function setLoader(isRunning, progressMessage, extraMessage, noTimer) {\n        const yasrInnerContainer = angular.element(document.getElementById(\"yasr-inner\"));\n        $scope.queryIsRunning = isRunning;\n        if (isRunning) {\n            $scope.queryStartTime = Date.now();\n            $scope.countTimeouted = false;\n            $scope.progressMessage = progressMessage;\n            $scope.extraMessage = extraMessage;\n            $scope.noLoaderTimer = noTimer;\n            yasrInnerContainer.addClass(\"hide\");\n        } else {\n            $scope.progressMessage = \"\";\n            $scope.extraMessage = \"\";\n            $scope.noLoaderTimer = false;\n            $scope.currentTrackAlias = null;\n            $scope.abortRequested = false;\n            yasrInnerContainer.removeClass(\"hide\");\n        }\n        // We might call this from angular or outside angular so take care of applying the scope.\n        if ($scope.$$phase === null) {\n            $scope.$apply();\n        }\n    }\n\n    function getLoaderMessage() {\n        const timeSeconds = (Date.now() - $scope.queryStartTime) / 1000;\n        let timeHuman = \"\";\n        let message = \"\";\n\n        if (!$scope.noLoaderTimer) {\n            timeHuman = $scope.getHumanReadableSeconds(timeSeconds);\n        }\n\n        if ($scope.progressMessage) {\n            message = $scope.progressMessage + \"... \" + timeHuman;\n        } else {\n            message = \"Running operation... \" + timeHuman;\n        }\n        if ($scope.extraMessage && timeSeconds > 10) {\n            message += \"\\n\" + $scope.extraMessage;\n        }\n\n        return message;\n    }\n\n    // start of query editor results orientation operations\n    function fixSizesOnHorizontalViewModeSwitch(verticalView) {\n        function visibleWindowHeight() {\n            return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0;\n        }\n\n        if (!$scope.orientationViewMode) {\n            $scope.noPadding = {paddingRight: 15, paddingLeft: 0};\n\n            // window.editor is undefined if no repo is selected\n            if (window.editor && document.querySelector('.CodeMirror-wrap')) {\n                let newHeight = visibleWindowHeight() - (document.querySelector('.CodeMirror-wrap').getBoundingClientRect().top);\n                newHeight -= 40;\n                document.querySelector('.CodeMirror-wrap').style.height = newHeight + 'px';\n                document.getElementById('yasr').style.minHeight = newHeight + 'px';\n                //window.editor.refresh();\n            } else {\n                let timer;\n                if (verticalView) {\n                    timer = $timeout(function () {\n                        $scope.fixSizesOnHorizontalViewModeSwitch(verticalView);\n                    }, 100);\n                } else {\n                    timer = $timeout($scope.fixSizesOnHorizontalViewModeSwitch, 100);\n                }\n\n                $scope.$on(\"$destroy\", function () {\n                    $timeout.cancel(timer);\n                });\n            }\n        } else {\n            if ($scope.viewMode === 'yasr') {\n                let newHeight = visibleWindowHeight() - (document.querySelector('.CodeMirror-wrap').getBoundingClientRect().top);\n                newHeight -= 40;\n                document.querySelector('.CodeMirror-wrap').style.height = newHeight + 'px';\n                //window.editor.refresh();\n            } else {\n                $scope.noPadding = {};\n                document.querySelector('.CodeMirror-wrap').style.height = '';\n                //window.editor.refresh();\n            }\n            document.getElementById('yasr').style.minHeight = '';\n        }\n        if (window.yasr && window.yasr.container) {\n            $timeout(function () {\n                window.yasr.container.resize();\n            }, 100);\n        }\n    }\n\n    if (!$scope.orientationViewMode) {\n        showHideEditor();\n    }\n\n    function changeViewMode() {\n        $scope.viewMode = 'none';\n        $scope.orientationViewMode = !$scope.orientationViewMode;\n        LocalStorageAdapter.set(LSKeys.VIEW_MODE, $scope.orientationViewMode);\n        fixSizesOnHorizontalViewModeSwitch();\n    }\n\n    function showHideEditor() {\n        fixSizesOnHorizontalViewModeSwitch(true);\n    }\n\n    function focusQueryEditor() {\n        if (!angular.element(document).find('.editable-input').is(\":focus\")) {\n            angular.element(document).find('.CodeMirror textarea:first-child').focus();\n        }\n    }\n\n    // end of query editor results orientation operations\n\n    function deleteCachedSparqlResults(foo, params) {\n        if (params.newRepo) {\n            $scope.tabsData = LocalStorageAdapter.get(LSKeys.TABS_STATE);\n            $scope.tabsData.forEach(function (item) {\n                item.yasrData = undefined;\n                item.queryType = undefined;\n                item.resultsCount = 0;\n                item.allResultsCount = 0;\n                item.sizeDelta = undefined;\n            });\n\n            LocalStorageAdapter.set(LSKeys.TABS_STATE, $scope.tabsData);\n            $scope.tabs = $scope.tabsData;\n\n            // The repository is changed. Remove error messages as well, if any\n            $scope.currentQuery = {};\n            $scope.errorMessage = null;\n            $scope.repositoryError = null;\n        }\n    }\n\n    function selectTab(id) {\n        $timeout(function () {\n            $('a[data-id = \"' + id + '\"]').tab('show');\n        }, 0);\n    }\n\n    window.onbeforeunload = function () {\n        if ($scope.currentQuery) {\n            $scope.saveTab($scope.currentQuery.id);\n        }\n        LocalStorageAdapter.set(LSKeys.TABS_STATE, $scope.tabs);\n    };\n\n    $scope.$on('$destroy', function () {\n        if ($scope.currentQuery) {\n            $scope.saveTab($scope.currentQuery.id);\n        }\n        LocalStorageAdapter.set(LSKeys.TABS_STATE, $scope.tabs);\n        clearInterval(checkQueryIntervalId);\n    });\n\n    // start of query operations\n    function runQuery(changePage, explain) {\n        $scope.executedQueryTab = $scope.currentQuery;\n        if (explain) {\n            if (!(window.editor.getQueryType() === 'SELECT' || window.editor.getQueryType() === 'CONSTRUCT')) {\n                toastr.warning('Explain only works with SELECT or CONSTRUCT queries.');\n                return;\n            }\n\n            if ($repositories.isActiveRepoOntopType()) {\n                toastr.warning('Explain not supported for Virtual repositories.');\n                return;\n            }\n        }\n\n        $scope.explainRequested = explain;\n        if (!$scope.queryIsRunning) {\n            if (changePage) {\n                $scope.currentTabConfig.resultsCount = 0;\n            } else {\n                $scope.resetCurrentTabConfig();\n            }\n\n            $scope.lastRunQueryMode = window.editor.getQueryMode();\n\n            if ($scope.lastRunQueryMode === 'update' && $repositories.isActiveRepoOntopType()) {\n                toastr.warning('Updates are not supported for Virtual repositories.');\n                return;\n            }\n\n            setLoader(true, $scope.lastRunQueryMode === 'update' ? 'Executing update' : 'Evaluating query');\n            if ($scope.viewMode !== 'none') {\n                $scope.viewMode = 'none';\n                if ($scope.orientationViewMode) {\n                    $scope.fixSizesOnHorizontalViewModeSwitch();\n                }\n                const timer = $timeout(window.editor.query, 500);\n                $scope.$on('$destroy', function () {\n                    $timeout.cancel(timer);\n                });\n            } else {\n                window.editor.query();\n            }\n        }\n    }\n\n    function abortCurrentQuery() {\n        MonitoringRestService.abortQueryByAlias($scope.currentTrackAlias)\n            .success(function () {\n                $scope.abortRequested = true;\n            });\n    }\n\n    function getNamespaces() {\n        // Signals the namespaces are to be fetched => loader will be shown\n        setLoader(true, 'Refreshing namespaces', 'Normally this is a fast operation but it may take longer if a bigger repository needs to be initialised first.');\n        $scope.namespacesLoading = true;\n\n        RDF4JRepositoriesRestService.getRepositoryNamespaces()\n            .success(function (data) {\n                const usedPrefixes = {};\n                data.results.bindings.forEach(function (e) {\n                    usedPrefixes[e.prefix.value] = e.namespace.value;\n                });\n                $scope.namespaces = usedPrefixes;\n            })\n            .error(function (data) {\n                $scope.repositoryError = getError(data);\n            })\n            .finally(function () {\n                // Signals namespaces were fetched => loader will be hidden\n                setLoader(false);\n                $scope.namespacesLoading = false;\n            });\n    }\n\n    function changePagination() {\n        runQuery(true, $scope.explainRequested);\n    }\n\n    $scope.$on(\"$destroy\", function () {\n        clearInterval(checkQueryIntervalId);\n        window.editor = null;\n        window.yasr = null;\n    });\n\n    function toggleSampleQueries() {\n        $scope.showSampleQueries = !$scope.showSampleQueries;\n        if ($scope.showSampleQueries) {\n            SparqlRestService.getSavedQueries()\n                .success(function (data) {\n                    $scope.sampleQueries = data;\n                    $('#sampleQueriesCollapse').collapse('show').width('300px');\n                })\n                .error(function (data) {\n                    const msg = getError(data);\n                    toastr.error(msg, 'Error! Could not get saved queries');\n                });\n        } else {\n            $('#sampleQueriesCollapse').collapse('hide');\n        }\n    }\n\n    // Hide the sample queries when the user clicks somewhere else in the UI.\n    $(document).mouseup(function (event) {\n        const container = $('#sampleQueriesCollapse');\n        if (!container.is(event.target) // if the target of the click isn't the container..\n            && container.has(event.target).length === 0 //... nor a descendant of the container\n            && $scope.showSampleQueries) {\n            toggleSampleQueries();\n        }\n    });\n\n    // Add known prefixes\n    function addKnownPrefixes() {\n        SparqlRestService.addKnownPrefixes(JSON.stringify(window.editor.getValue()))\n            .success(function (data) {\n                if (angular.isDefined(window.editor) && angular.isDefined(data) && data !== window.editor.getValue()) {\n                    window.editor.setValue(data);\n                }\n            })\n            .error(function (data) {\n                const msg = getError(data);\n                toastr.error(msg, 'Error! Could not add known prefixes');\n                return true;\n            });\n    }\n\n    function querySelected(query) {\n        const tabId = getExistingTabId(query);\n        $scope.toggleSampleQueries();\n\n        if ($scope.isTabChangeOk(false)) {\n            $scope.highlightNextTabChange = true;\n            if (!angular.isDefined(tabId)) {\n                $scope.addNewTab(null, query.name, query.body);\n            } else {\n                selectTab(tabId);\n            }\n        }\n    }\n\n    function getExistingTabId(query) {\n        let existingTabId = undefined;\n        $scope.tabsData.forEach(function (item) {\n            if (item.name === query.name && item.query === query.body) {\n                existingTabId = item.id;\n                return item;\n            }\n        });\n        return existingTabId;\n    }\n\n    function editQuery(query) {\n        const modalInstance = $modal.open({\n            templateUrl: 'js/angular/core/directives/queryeditor/templates/query-sample.html',\n            controller: 'QuerySampleModalCtrl',\n            resolve: {\n                data: function () {\n                    return {\n                        title: 'Edit Saved Query: \"' + query.name + '\"',\n                        query: query,\n                        edit: true,\n                        okButtonText: 'Save'\n                    };\n                }\n            }\n        });\n\n        modalInstance.result.then(function (queryModal) {\n            const data = {\n                name: queryModal.name,\n                body: queryModal.body,\n                shared: queryModal.shared\n            };\n            if (query.name !== queryModal.name) {\n                SparqlRestService.addNewSavedQuery(data)\n                    .success(function () {\n                        $scope.deleteQueryHttp(query.name, true);\n                    })\n                    .error(function (data) {\n                        const msg = getError(data);\n                        toastr.error(msg, 'Error! Cannot edit saved query');\n                    });\n            } else {\n                SparqlRestService.editSavedQuery(data)\n                    .success(function () {\n                        $('#editQueryContainer').modal('hide');\n                        $scope.toggleSampleQueries();\n                        toastr.success('Saved query ' + query.name + ' was edited.');\n                    })\n                    .error(function (data) {\n                        const msg = getError(data);\n                        toastr.error(msg, 'Error! Cannot edit Saved query');\n                    });\n            }\n        });\n    }\n\n    function deleteQueryHttp(savedQueryName, edit) {\n        SparqlRestService.deleteSavedQuery(savedQueryName)\n            .success(function () {\n                $scope.toggleSampleQueries();\n                if (!edit) {\n                    toastr.success('Saved query: ' + savedQueryName + ' was deleted.');\n                }\n            })\n            .error(function (data) {\n                const msg = getError(data);\n                toastr.error(msg, 'Error! Cannot delete saved query');\n            });\n    }\n\n    function deleteQuery(savedQueryName) {\n        ModalService.openSimpleModal({\n            title: 'Confirm',\n            message: 'Are you sure you want to delete the saved query ' + '\\'' + savedQueryName + '\\'?',\n            warning: true\n        }).result\n            .then(function () {\n                $scope.deleteQueryHttp(savedQueryName);\n            });\n    }\n\n    function saveQueryHttp(query) {\n        SparqlRestService.addNewSavedQuery(query)\n            .success(function () {\n                toastr.success('Saved query ' + query.name + ' was saved.');\n            })\n            .error(function (data) {\n                let msg = getError(data);\n                toastr.error(msg, 'Error! Cannot create saved query');\n                // TODO: This condition will always be true\n                if (msg = \"Query '\" + query.name + \"' already exists!\") {\n                    query.query = query.body;\n                    const queryExists = true;\n                    $scope.saveQuery(query, queryExists);\n                }\n            });\n    }\n\n    function saveQuery(query, queryExists) {\n        const modalInstance = $modal.open({\n            templateUrl: 'js/angular/core/directives/queryeditor/templates/query-sample.html',\n            controller: 'QuerySampleModalCtrl',\n            resolve: {\n                data: function () {\n                    return {\n                        title: 'Create New Saved Query',\n                        query: {name: query.name, body: query.query, shared: query.shared},\n                        edit: false,\n                        okButtonText: 'Create',\n                        queryExists: queryExists\n                    };\n                }\n            }\n        });\n\n        modalInstance.result.then(function (query) {\n            $scope.saveQueryHttp(query);\n        }, function () {\n        });\n    }\n\n    // end of query operations\n\n    function showModal(modalSelector) {\n        return function (name, query, shared) {\n            $scope.savedQuery = {\n                name: name,\n                query: query || window.editor.getValue(),\n                shared: shared\n            };\n            $(modalSelector).modal('show');\n        };\n    }\n\n\n    // start of query tab operations\n    function findTabIndexByID(id) {\n        for (let i = 0; i < $scope.tabsData.length; i++) {\n            const tab = $scope.tabsData[i];\n            if (tab.id === id) {\n                return i;\n            }\n        }\n    }\n\n    function saveTab(id) {\n        const idx = findTabIndexByID(id);\n        // Tab was deleted, don't try to save it's state\n        if (idx === undefined) {\n            return {};\n        }\n        const tab = $scope.tabsData[idx];\n        //tab.query = window.editor.getValue();\n        $scope.saveQueryToLocal(tab);\n        return tab;\n    }\n\n    let maxID = LocalStorageAdapter.get(LSKeys.TABS_STATE_MAXID) || 1;\n\n    function addNewTab(callback, tabName, savedQuery) { // optional callback to call after tab has been added\n        if (!isTabChangeOk(true)) {\n            return;\n        }\n        let defaultTabConfig;\n        if (tabName || savedQuery) {\n            defaultTabConfig = {\n                id: \"1\",\n                name: tabName,\n                query: savedQuery,\n                inference: principal.appSettings.DEFAULT_INFERENCE,\n                sameAs: principal.appSettings.DEFAULT_SAMEAS\n            };\n        } else {\n            defaultTabConfig = {\n                id: \"1\",\n                name: '',\n                query: 'select * where { \\n' +\n                '\\t?s ?p ?o .\\n' +\n                '} limit 100 \\n',\n                inference: principal.appSettings.DEFAULT_INFERENCE,\n                sameAs: principal.appSettings.DEFAULT_SAMEAS\n            };\n        }\n\n        maxID++;\n        const newID = '' + maxID;\n        $scope.tabsData = $scope.tabs;\n\n        const newTab = defaultTabConfig;\n        newTab.id = newID;\n\n        $scope.tabsData.push(newTab);\n\n        LocalStorageAdapter.set(LSKeys.TABS_STATE_MAXID, maxID);\n        LocalStorageAdapter.set(LSKeys.TABS_STATE, $scope.tabsData);\n        const callbackArgs = Array.prototype.slice.call(arguments, 1); // skip one argument, i.e. the callback itself\n        $timeout(function () {\n            $scope.$apply();\n            selectTab(newID);\n            if (callback) {\n                callback.apply(this, callbackArgs);\n            }\n        }, 0);\n        $scope.tabs = $scope.tabsData;\n    }\n\n    function loadTab(id) {\n        $scope.tabsData = LocalStorageAdapter.get(LSKeys.TABS_STATE) || [defaultTabConfig];\n\n        // find available tab\n        const idx = findTabIndexByID(id);\n        const tab = $scope.tabsData[idx];\n\n        if (tab.yasrData) {\n            setLoader(true, 'Rendering results', null, true);\n        }\n\n        // set query in editor available on the current tab\n        $timeout(function () {\n            if ($scope.currentQuery.query === '') {\n                $scope.currentQuery.query = \" \";\n            }\n            $timeout(function () {\n                window.editor.setValue($scope.currentQuery.query);\n                $scope.yasr.updateDownloadDropdown();\n                $scope.$broadcast('tabLoaded', $scope.currentQuery.id);\n\n                // set query results in query results sections after\n                // previous query execution. Yasr response rendering depends on the\n                // query type of window.editor!\n                $scope.yasr.options.output = tab.outputType; // this may be undefined, that's fine!\n                if (tab.yasrData) {\n                    if (tab.yasrData.customError) {\n                        // Our injected custom (not real HTTP) error\n                        $scope.yasr.results = {\n                            getException: function () {\n                                return tab.yasrData.customError;\n                            }\n                        };\n                        setLoader(false);\n                    } else {\n                        // Real YASR result\n                        $timeout(function () {\n                            $scope.setYasrResponse(tab.yasrData, tab.textStatus, tab.jqXhrOrErrorString);\n                            setLoader(false);\n                            if ($('.yasr_btnGroup li:nth-child(2)').hasClass(\"active\")) {\n                                $timeout(function () {\n                                    $('.yasr_btnGroup li:nth-child(2) a').get(0).click();\n                                }, 0);\n                            }\n                        }, 0);\n                    }\n                }\n            }, 0);\n        }, 0);\n\n\n        // persist current tab id in local storage\n        LocalStorageAdapter.set(LSKeys.TABS_STATE_CURRENT_ID, id);\n\n        $scope.currentQuery = tab;\n\n        $timeout(function () {\n            $scope.currentTabConfig = {};\n            $scope.currentTabConfig.queryType = tab.queryType;\n            $scope.currentTabConfig.resultsCount = tab.resultsCount;\n\n            $scope.currentTabConfig.offset = tab.offset;\n            $scope.currentTabConfig.allResultsCount = tab.allResultsCount;\n            $scope.currentTabConfig.allResultsCountExact = tab.allResultsCountExact;\n            $scope.currentTabConfig.page = tab.page;\n            $scope.currentTabConfig.pageSize = tab.pageSize;\n\n            $scope.currentTabConfig.timeFinished = tab.timeFinished;\n            $scope.currentTabConfig.timeTook = tab.timeTook;\n            $scope.currentTabConfig.sizeDelta = tab.sizeDelta;\n            $scope.currentTabConfig.customUpdateMessage = tab.customUpdateMessage;\n            $scope.currentTabConfig.errorMessage = tab.errorMessage;\n            $scope.currentTabConfig.warningMessage = tab.warningMessage;\n\n            $scope.$apply();\n        }, 0);\n\n        //Remove paddign of yasr so it will be aligned with sparql editor\n        $('#yasr').css('padding', '0');\n\n        if (!checkQueryIntervalId) {\n            checkQueryIntervalId = setInterval(showOrHideSaveAsDropDown, 200);\n        }\n        overrideSameAsInferenceAndNoCountIfNeeded();\n    }\n\n    function getQueryID(element) {\n        return $(element).attr('data-id');\n    }\n\n    function showOrHideSaveAsDropDown() {\n        // If selected tab has results and query in editor controller is invalid save as\n        // dropdown menu will be removed and on fixing query latter will be added\n        if ($scope.currentTabConfig.resultsCount >= 0) {\n            const $saveAsDropDown = $('.saveAsDropDown');\n            if ($saveAsDropDown.length > 0 && !window.editor.queryValid) {\n                yasr.header.find('.saveAsDropDown').remove();\n            } else if ($saveAsDropDown.length === 0 && window.editor.queryValid) {\n                yasr.updateDownloadDropdown();\n            }\n        }\n    }\n\n    function isTabChangeOk(isNew) {\n        if ($scope.queryIsRunning && !$scope.namespacesLoading) {\n            if (isNew) {\n                toastr.info('New tabs may not be opened while query or update is running.');\n            } else {\n                toastr.info('Tabs may not be switched while query or update is running.');\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    // Raise this flag to provide visual feedback to the user the next time a tab changes\n    // (either manually or by the system). See GDB-1983.\n    $scope.highlightNextTabChange = false;\n    $scope.$on('tabAction', function (e, tabEvent) {\n        if (tabEvent.relatedTarget) {\n            // Cancel any highlight timer that might have been left by the last highlight\n            $timeout.cancel(tabEvent.relatedTarget.timer);\n            $(tabEvent.relatedTarget).css('color', '');\n\n            $scope.saveTab(getQueryID(tabEvent.relatedTarget));\n        }\n\n        $scope.loadTab(getQueryID(tabEvent.target));\n\n        // These arrays define how the tab change will be visually enhanced.\n        // colors contains the colors to set to the tab name,\n        // while times defines the times in milliseconds to keep each color.\n        // Once we cycle through the arrays we restore the default color.\n        const colors = ['#ED4F2F', '', '#ED4F2F'];\n        const times = [400, 400, 400];\n        if ($scope.highlightNextTabChange) {\n            $scope.highlightNextTabChange = false;\n            let index = 0;\n            $(tabEvent.target).css('color', colors[index]);\n            const highlightFun = function () {\n                index++;\n                if (index < colors.length) {\n                    $(tabEvent.target).css('color', colors[index]);\n                    tabEvent.target.timer = $timeout(highlightFun, times[index]);\n                } else {\n                    $(tabEvent.target).css('color', '');\n                }\n            };\n            $timeout(highlightFun, times[index]);\n        }\n    });\n\n    $scope.$on('deleteAllexeptSelected', function (e, tabs) {\n        $scope.tabsData = tabs;\n        $scope.tabs = tabs;\n    });\n    // end of query tab operations\n\n    $scope.currentQuery = {};\n    // $scope.state = {};\n    $scope.showSampleQueries = false;\n    $scope.savedQuery = {};\n    $scope.sampleQueries = {};\n    $scope.editQueryModal = showModal('#editQueryContainer');\n    $scope.deleteQueryModal = showModal('#confirmDeleteContainer');\n    $scope.saveQueryModal = showModal('#saveQueryContainer');\n\n    $scope.getResultsDescription = function () {\n        let desc;\n        if ($scope.currentTabConfig.resultsCount === 0) {\n            desc = \"No results.\";\n        } else {\n            const currentPageEnd = ($scope.currentTabConfig.page - 1) * $scope.currentTabConfig.pageSize\n                + Math.min($scope.currentTabConfig.resultsCount, $scope.currentTabConfig.pageSize);\n            desc = \"Showing results from \" + $filter('currency')($scope.currentTabConfig.offset, '', 0)\n                + \" to \" + $filter('currency')(currentPageEnd, '', 0);\n            if ($scope.currentTabConfig.allResultsCount > 0) {\n                // Unsure total results count \"of at least\" happens if counting timed out or\n                // counting was disabled and we got at least $pageSize + 1 results for the current page.\n                // It may reset become exact when we navigate and reach the end of results.\n                desc += $scope.currentTabConfig.allResultsCountExact\n                    ? \" of \" : \" of at least \";\n                desc += $filter('currency')($scope.currentTabConfig.allResultsCount, '', 0);\n            }\n            desc += \".\";\n        }\n\n        return desc;\n    };\n\n    $scope.getUpdateDescription = function () {\n        if ($scope.currentTabConfig.customUpdateMessage) {\n            return $scope.currentTabConfig.customUpdateMessage;\n        } else if ($scope.currentTabConfig.sizeDelta === undefined) {\n            return '';\n        } else if ($scope.currentTabConfig.sizeDelta < 0) {\n            return 'Removed ' + Math.abs($scope.currentTabConfig.sizeDelta) + ' statements.';\n        } else if ($scope.currentTabConfig.sizeDelta > 0) {\n            return 'Added ' + $scope.currentTabConfig.sizeDelta + ' statements.';\n        } else {\n            return 'The number of statements did not change.';\n        }\n    };\n\n    $scope.getStaleWarningMessage = function () {\n        const secondsAgo = Math.round((Date.now() - $scope.currentTabConfig.timeFinished) / 60000) * 60;\n        if (secondsAgo >= 3600) { // must be at least an hour\n            return \"Possibly stale result (obtained \" + $scope.getHumanReadableSeconds(secondsAgo) + \" ago).\";\n        }\n    };\n\n    const resize = function () {\n        // $scope.fixSizesOnHorizontalViewModeSwitch();\n    };\n\n    angular.element($window).bind('resize', resize);\n\n    $scope.$on('$destroy', function () {\n        angular.element($window).unbind('resize', resize);\n    });\n\n    /**\n     * In case of Ontop repository, sameAs, inference and nocount are\n     * overridden to true and #sameAs and #inference buttons is disabled, In case of FedX repo nocount is overriden\n     */\n    function overrideSameAsInferenceAndNoCountIfNeeded() {\n        const isOntop = $repositories.isActiveRepoOntopType();\n        const isFedX = $repositories.isActiveRepoFedXType();\n        handleSameAsAndInferenceBtns(isOntop);\n\n        $scope.nocount = (isOntop || isFedX) ? true : !principal.appSettings.EXECUTE_COUNT;\n        $scope.currentQuery.inference = isOntop ? true : principal.appSettings.DEFAULT_INFERENCE;\n        $scope.currentQuery.sameAs = isOntop ? true : principal.appSettings.DEFAULT_SAMEAS;\n    }\n\n    function handleSameAsAndInferenceBtns(isOntop) {\n        const sameAsBtn = document.getElementById('sameAs');\n        const inferenceBtn = document.getElementById('inference');\n\n        sameAsBtn.disabled = !!(sameAsBtn && isOntop);\n        inferenceBtn.disabled = !!(inferenceBtn && isOntop);\n    }\n}\n\nQuerySampleModalCtrl.$inject = ['$scope', '$modalInstance', 'data'];\n\nfunction QuerySampleModalCtrl($scope, $modalInstance, data) {\n    if (data.queryExists) {\n        $scope.queryExists = true;\n    }\n    $scope.query = angular.copy(data.query);\n    $scope.title = data.title;\n    $scope.edit = data.edit;\n    $scope.okButtonText = data.okButtonText;\n    $scope.ok = function () {\n        if ($scope.form.$valid) {\n            $modalInstance.close($scope.query);\n        }\n    };\n\n    $scope.cancel = function () {\n        $modalInstance.dismiss('cancel');\n    };\n}\n","import 'angular/rest/connectors.rest.service';\nimport 'angular/utils/local-storage-adapter';\nimport 'angular/externalsync/controllers';\nimport YASQE from 'lib/yasqe.bundled';\nimport YASR from 'lib/yasr.bundled';\n\nangular\n    .module('graphdb.framework.core.directives.queryeditor.queryeditor', [\n        'ngCookies',\n        'graphdb.framework.externalsync.controllers',\n        'graphdb.framework.rest.connectors.service',\n        'graphdb.framework.utils.localstorageadapter'\n    ])\n    .directive('queryEditor', queryEditorDirective);\n\nqueryEditorDirective.$inject = ['$timeout', '$location', 'toastr', '$repositories', 'SparqlRestService', 'ModalService', '$modal', '$jwtAuth', 'RDF4JRepositoriesRestService', 'ConnectorsRestService', 'LocalStorageAdapter', 'LSKeys'];\n\nfunction queryEditorDirective($timeout, $location, toastr, $repositories, SparqlRestService, ModalService, $modal, $jwtAuth, RDF4JRepositoriesRestService, ConnectorsRestService, LocalStorageAdapter, LSKeys) {\n\n    let callbackOnChange;\n\n    return {\n        restrict: 'AE',\n        scope: false,\n        templateUrl: 'js/angular/core/directives/queryeditor/templates/query-editor.html',\n        link: linkFunc\n    };\n\n    //function updateLineGutter() in Yasqe receive wrong data and line numbers div have width 100%\n    // magic value 150 seems to work well (including Safari), smaller values work on other browsers but not always on Safari\n    function linkFunc(scope, element, attrs) {\n        // Doesn't store anything in local storage\n        scope.nostorage = attrs.hasOwnProperty('nostorage');\n        // Doesn't allow multiple tabs in the editor, only a single tab is active\n        scope.notabs = attrs.hasOwnProperty('notabs');\n        // Hides all the vertical toolbar inside the editor\n        scope.notoolbar = attrs.hasOwnProperty('notoolbar');\n        // Hides the saved queries icons in the toolbar\n        scope.notoolbarSaved = attrs.hasOwnProperty('notoolbarSaved');\n        // Hides the copy query link icon in the toolbar\n        scope.notoolbarCopy = attrs.hasOwnProperty('notoolbarCopy');\n        // Hides the inference icon in the toolbar\n        scope.notoolbarInference = attrs.hasOwnProperty('notoolbarInference');\n        // Hides the sameAs icon in the toolbar\n        scope.notoolbarSameAs = attrs.hasOwnProperty('notoolbarSameAs');\n        // Doesn't show any status messages in YASR (e.g. no results, query took that many seconds, etc)\n        scope.nostatus = attrs.hasOwnProperty('nostatus');\n        // Doesn't show the run button\n        scope.norun = attrs.hasOwnProperty('norun');\n        // Name of the Run button in the editor\n        scope.runButtonName = \"Run\";\n        if (attrs.runButtonName) {\n            scope.runButtonName = attrs.runButtonName;\n        }\n        // Doesn't execute the count query\n        scope.nocount = attrs.nocount === \"true\";\n\n        // Custom callback to call when the content changes (fired within timeout of 200)\n        if (attrs.callbackOnChange) {\n            const callback = scope[attrs.callbackOnChange];\n            if (typeof callback === 'function') {\n                callbackOnChange = callback;\n            }\n        }\n\n        $timeout(function () {\n            drawQueryEditor(scope);\n        }, 150);\n    }\n\n    function drawQueryEditor(scope) {\n        scope.changePagination = changePagination;\n\n        // start of keyboard shortcut actions\n        function saveQueryAction() {\n            angular.element('#wb-sparql-saveQuery')[0].click();\n        }\n\n        function runQueryAction() {\n            scope.runQuery(false, false);\n        }\n\n        function explainQueryAction() {\n            scope.runQuery(false, true);\n        }\n\n        function goToNextTabAction() {\n            if (scope.tabs.length < 2 || !scope.currentQuery.id || !scope.isTabChangeOk(false)) {\n                return;\n            }\n            let idx = findTabIndexByID(scope.currentQuery.id);\n            idx = (idx + 1) % scope.tabs.length;\n            const tab = scope.tabs[idx];\n            selectTab(tab.id);\n        }\n\n        function goToPreviousTabAction() {\n            if (scope.tabs.length < 2 || !scope.currentQuery.id || !scope.isTabChangeOk(false)) {\n                return;\n            }\n            let idx = findTabIndexByID(scope.currentQuery.id);\n            idx--;\n            if (idx === -1) {\n                idx = scope.tabs.length - 1;\n            }\n            const tab = scope.tabs[idx];\n            selectTab(tab.id);\n        }\n\n        window.editor = YASQE.fromTextArea(\n            document.getElementById(\"query\"), {\n                persistent: null,\n                value: \"\",\n                indentUnit: 4,\n                createShareLink: null,\n                cursorHeight: 1.0,\n                sparql: {\n                    showQueryButton: false,\n                    acceptHeaderGraph: \"application/x-graphdb-table-results+json, application/rdf+json;q=0.9, */*;q=0.8\",\n                    acceptHeaderSelect: \"application/x-sparqlstar-results+json, application/sparql-results+json;q=0.9, */*;q=0.8\"\n                },\n                // We provide a wrapper for executeQuery so we have to redefine those here\n                extraKeys: {\n                    \"Ctrl-Enter\": runQueryAction,\n                    \"Cmd-Enter\": runQueryAction,\n                    \"Shift-Ctrl-Enter\": explainQueryAction,\n                    \"Shift-Cmd-Enter\": explainQueryAction,\n                    \"Ctrl-Alt-T\": scope.addNewTab,\n                    \"Cmd-Alt-T\": scope.addNewTab,\n                    \"Ctrl-S\": saveQueryAction,\n                    \"Cmd-S\": saveQueryAction,\n                    \"Ctrl-Alt-Left\": goToPreviousTabAction,\n                    \"Cmd-Alt-Left\": goToPreviousTabAction,\n                    \"Ctrl-Alt-Right\": goToNextTabAction,\n                    \"Cmd-Alt-Right\": goToNextTabAction\n                }\n            }\n        );\n\n        window.editor.toastBuildIndex = function () {\n            toastr.warning('', '<div class=\"autocomplete-toast\"><a href=\"autocomplete\">Autocomplete is OFF<br>Go to Setup -> Autocomplete</a></div>',\n                {allowHtml: true});\n        };\n\n        window.editor.toastError = function (data) {\n            toastr.error('Cannot execute autocomplete query. ' + getError(data));\n        };\n\n        window.editor.on(\"changes\", function () {\n            angular.element('.CodeMirror-linenumbers').css('width', '1px');\n            angular.element('.CodeMirror-sizer').css('margin-left', '0px');\n            clearTimeout(scope.changesTimeout);\n            const hasError = !window.editor.queryValid;\n            scope.changesTimeout = setTimeout(callbackOnChange ? callbackOnChange() : function () {\n                const idx = findTabIndexByID(scope.currentQuery.id) + 1;\n                $('a[data-id = \"' + idx + '\"]')\n                    .toggleClass('query-has-error', hasError)\n                    .attr('title', hasError ?\n                        'Query contains a syntax error. See the relevant line for more information.' :\n                        '');\n            }, 200);\n            scope.currentQuery.query = window.editor.getValue();\n            scope.currentQuery.queryType = window.editor.getQueryType();\n        });\n\n\n        function selectTab(id) {\n            $timeout(function () {\n                let requestedTab = $('a[data-id = \"' + id + '\"]');\n                if (requestedTab.length === 0) {\n                    // tab has been deleted in another browser window or something else occurred,\n                    // select first tab instead\n                    requestedTab = $('a[data-id]').first();\n                }\n                requestedTab.tab('show');\n            }, 0);\n        }\n\n        // hide unneeded yasqe fullscreen button\n        $(\".fullscreenToggleBtns\").hide();\n\n        const afterCopy = function (event) {\n            $(event.target).removeClass('fa-link').addClass('fa-check').blur();\n            setTimeout(function () {\n                $(event.target).removeClass('fa-check').addClass('fa-link');\n            }, 1000);\n        };\n\n        window.onbeforeunload = function () {\n            if (!scope.nostorage) {\n                LocalStorageAdapter.set(LSKeys.TABS_STATE, scope.tabs);\n            }\n            scope.saveTab(scope.currentQuery.id);\n        };\n\n        /*\n         * Patch the execute query to take into account the inference\n         * and the same as options\n         */\n        const originalExecuteQuery = YASQE.executeQuery;\n        const originalGetUrlArguments = YASQE.getUrlArguments;\n\n        scope.$on('$destroy', function () {\n            if (!scope.nostorage) {\n                LocalStorageAdapter.set(LSKeys.TABS_STATE, scope.tabs);\n            }\n            YASQE.executeQuery = originalExecuteQuery;\n            YASQE.getUrlArguments = originalGetUrlArguments;\n            scope.saveTab(scope.currentQuery.id);\n        });\n\n        /*\n         * Add our own buttons\n         */\n        YASQE.drawButtons = function (yasqe) {\n            // Define this property because otherwise there are errors in yasgui's code.\n            yasqe.buttons = $(\"#yasqe_buttons_mocked\");\n        };\n\n        YASQE.getActiveRepository = function () {\n            return $repositories.getActiveRepository();\n        };\n\n        YASQE.getUrlArguments = function (yasqe, config) {\n            const data = originalGetUrlArguments(yasqe, config);\n            const qType = window.editor.getQueryType();\n            if ('SELECT' === qType || 'CONSTRUCT' === qType || 'DESCRIBE' === qType) {\n                // We request pageSize + 1 to know if there are more pages when total count isn't known\n                data.push({name: 'limit', value: scope.currentTabConfig.pageSize + 1});\n                scope.currentTabConfig.offset = (scope.currentTabConfig.page - 1) * scope.currentTabConfig.pageSize + 1;\n                data.push({name: 'offset', value: scope.currentTabConfig.offset - 1});\n            }\n            // even though we have explainRequested in our scope too it doesn't always contain a fresh value\n            if (scope.explainRequested && ('SELECT' === qType || 'CONSTRUCT' === qType)) {\n                data.push({name: 'explain', value: 'true'});\n            }\n            return data;\n        };\n\n        function createCustomError(status, statusText, responseText) {\n            return {\n                status: status,\n                statusText: statusText,\n                responseText: responseText\n            };\n        }\n\n        // Generates a new tracking alias for queries based on time\n        function newTrackAlias() {\n            return \"query-editor-\" + performance.now() + \"-\" + Date.now();\n        }\n\n        let connectorProgressModal;\n        let yasr;\n\n        YASQE.executeQuery = function (cm) {\n            if (yasr && $(yasr.resultsContainer).length) {\n                $(yasr.resultsContainer).empty();\n            }\n            // Request extra error/warning handling\n            cm.options.sparql.headers['X-GraphDB-Catch'] = scope.currentTabConfig.pageSize + '; throw';\n            scope.currentTrackAlias = newTrackAlias();\n            cm.options.sparql.headers['X-GraphDB-Track-Alias'] = scope.currentTrackAlias;\n            scope.countTimeouted = false;\n            if (cm.getQueryMode() === 'query') {\n                cm.options.sparql.endpoint = 'repositories/' + $repositories.getActiveRepository();\n            } else if (cm.getQueryMode() === 'update') {\n                cm.options.sparql.endpoint = 'repositories/' + $repositories.getActiveRepository() + '/statements';\n            }\n            cm.options.sparql.args = [{\n                name: 'infer',\n                value: scope.currentQuery.inference\n            },\n                {\n                    name: 'sameAs',\n                    value: scope.currentQuery.sameAs\n                }];\n\n            scope.currentTabConfig.customUpdateMessage = \"\";\n\n            if (window.editor.getQueryMode() === \"update\") {\n                const doExecute = function () {\n                    scope.currentTabConfig.queryType = \"UPDATE\";\n\n                    RDF4JRepositoriesRestService.getRepositorySize()\n                        .success(function (data) {\n                            scope.repoSize = parseInt(data);\n                            scope.queryStartTime = new Date().getTime();\n                            return originalExecuteQuery(cm, {});\n                        })\n                        .error(function (data) {\n                            toastr.warning('Could not get repository size for: ' + $repositories.getActiveRepository() + '; ' + getError(data));\n                            scope.queryStartTime = new Date().getTime();\n                            return originalExecuteQuery(cm, {});\n                        });\n                };\n\n                ConnectorsRestService.checkConnector(window.editor.getValue())\n                    .then(function (res) {\n                        if (res.data.command && !res.data.hasSupport) {\n                            // it's a connector query but the relevant plugin isn't active, stop executing and warn the user\n                            scope.currentTabConfig.queryType = 'ERROR';\n                            scope.currentTabConfig.timeFinished = Date.now();\n                            scope.currentTabConfig.timeTook = (scope.currentTabConfig.timeFinished - scope.queryStartTime) / 1000;\n\n                            const customError = createCustomError(-1, 'No support for ' + res.data.connectorName, res.data.connectorName\n                                + ' connectors are not supported because the plugin ' + res.data.pluginName + ' is not active.');\n\n                            yasr.results = {\n                                getException: function () {\n                                    return customError;\n                                }\n                            };\n\n                            scope.setLoader(false);\n\n                            setNewTabState({customError: customError}, '', null);\n\n                            return;\n                        }\n\n                        if (res.data.command === 'create' || res.data.command === 'repair') {\n                            const repair = res.data.command === 'repair';\n                            if (repair) {\n                                scope.setLoader(true, 'Repairing connector ' + res.data.name);\n                                scope.currentTabConfig.customUpdateMessage = 'Repaired connector ' + res.data.name + '.';\n                            } else {\n                                scope.setLoader(true, 'Creating connector ' + res.data.name);\n                                scope.currentTabConfig.customUpdateMessage = 'Created connector ' + res.data.name + '.';\n                            }\n\n                            const progressScope = scope.$new(true);\n\n                            // This duplicates code in the externalsync module but we can't get it from there\n                            progressScope.beingBuiltConnector = {\n                                percentDone: 0,\n                                status: {\n                                    processedEntities: 0,\n                                    estimatedEntities: 0,\n                                    indexedEntities: 0,\n                                    entitiesPerSecond: 0\n                                },\n                                actionName: repair ? 'Repairing' : 'Creating',\n                                eta: \"-\",\n                                inline: false,\n                                iri: res.data.iri,\n                                name: res.data.name,\n                                doneCallback: function () {\n                                    connectorProgressModal.dismiss('cancel');\n                                }\n                            };\n                            progressScope.getHumanReadableSeconds = scope.getHumanReadableSeconds;\n\n                            connectorProgressModal = $modal.open({\n                                templateUrl: 'pages/connectorProgress.html',\n                                controller: 'CreateProgressCtrl',\n                                size: 'lg',\n                                backdrop: 'static',\n                                scope: progressScope\n                            });\n                        } else if (res.data.command === 'drop') {\n                            scope.setLoader(true, 'Deleting connector ' + res.data.name);\n                            scope.currentTabConfig.customUpdateMessage = 'Deleted connector ' + res.data.name + '.';\n                        }\n\n                        doExecute();\n                    }, function () {\n                        // for some reason we couldn't check if this is a connector update, so just execute it\n                        doExecute();\n                    });\n\n            } else {\n                const thisTabConfig = scope.currentTabConfig;\n                const thisTabId = scope.executedQueryTab.id;\n\n                // Assign a fresh callback function so that we can associate the count result\n                // with the right tab (or lack of tab).\n                window.editor.options.sparql.handlers.countCallback = function (dataOrJqXhr, textStatus, jqXhrOrErrorString) {\n                    if (dataOrJqXhr.status === 200) {\n                        const tab = scope.tabs[findTabIndexByID(thisTabId)];\n                        if (tab) {\n                            yasr.setResultsCount(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n                            thisTabConfig.allResultsCount = yasr.allCount;\n                            tab.allResultsCount = yasr.allCount;\n                            thisTabConfig.allResultsCountExact = true;\n                            tab.allResultsCountExact = true;\n                            scope.saveTab(tab.id);\n                        } // Else tab was closed while we wait for the count, ignore result\n                    } else {\n                        // count query timed out or something else went wrong\n                        thisTabConfig.countTimeouted = true;\n                    }\n                };\n\n                // Tell YASR what format we want, or else it will mess it up when switching between tabs.\n                if (scope.currentQuery.outputType != null) {\n                    yasr.options.output = scope.currentQuery.outputType;\n                } else { // Default to table if no format has been configured yet.\n                    yasr.options.output = \"table\";\n                }\n                scope.currentTabConfig.queryType = window.editor.getQueryType();\n                scope.queryStartTime = new Date().getTime();\n                return originalExecuteQuery(cm, {\n                    setQueryLimit: function (query) {\n                        // Until weird conversion of CONSTRUCT queries is fixed\n                        // in Ontop project, comments should be removed from them\n                        // TODO: Remove this check when ${link https://github.com/ontop/ontop/issues/362} is fixed\n                        if (scope.currentTabConfig.queryType === 'CONSTRUCT' && $repositories.isActiveRepoOntopType()) {\n                            return window.editor.getValueWithoutComments();\n                        }\n                        // For all types of queries we handle limit/offset in our RepositoriesController.\n                        // TODO: Get rid of this method\n                        return query;\n                    }\n                });\n            }\n\n        };\n\n        // Override yasqe's getAjaxConfig() so we can inject our authorization header\n        const originalGetAjaxConfig = YASQE.getAjaxConfig;\n        YASQE.getAjaxConfig = function (yasqe, callbackOrConfig) {\n            const config = originalGetAjaxConfig(yasqe, callbackOrConfig);\n\n            _.extend(config.headers, {\n                'Authorization': $jwtAuth.getAuthToken()\n            });\n\n            return config;\n        };\n\n        function createQueryURL(savedQueryName, owner) {\n            let url = [location.protocol, '//', location.host, location.pathname].join('');\n            if (savedQueryName) {\n                url = url + '?savedQueryName=' + encodeURIComponent(savedQueryName);\n                if (owner != null) {\n                    url += '&owner=' + encodeURIComponent(owner);\n                }\n            } else {\n                url = url + '?' + $.param({\n                    name: scope.currentQuery.name,\n                    infer: scope.currentQuery.inference,\n                    sameAs: scope.currentQuery.sameAs,\n                    query: window.editor.getValue()\n                });\n            }\n            return url;\n        }\n\n        scope.copyToClipboardQuery = function (savedQueryName, owner) {\n            ModalService.openCopyToClipboardModal(createQueryURL(savedQueryName, owner));\n        };\n\n        scope.copyToClipboardResult = function (resultURI) {\n            ModalService.openCopyToClipboardModal(resultURI);\n        };\n\n        scope.goToVisual = function () {\n            const paramsToParse = {\n                query: window.editor.getValue(),\n                sameAs: scope.currentQuery.sameAs,\n                inference: scope.currentQuery.inference\n            };\n\n            $location.path('graphs-visualizations').search(paramsToParse);\n        };\n\n        // Adds prefixes when the user pastes a query. This was in the controller before and it stopped working\n        // (needs to happen to after YASQE adds the textarea), see GDB-1936\n        $('textarea').on('paste', function () {\n            $timeout(function () {\n                scope.addKnownPrefixes();\n            }, 0);\n        });\n\n        function setNewTabState(dataOrJqXhr, textStatus, jqXhrOrErrorString) {\n            // store explicitly the contentType\n            if (dataOrJqXhr.getResponseHeader && dataOrJqXhr.getResponseHeader(\"content-type\")) {\n                dataOrJqXhr.contentType = dataOrJqXhr.getResponseHeader(\"content-type\");\n            }\n\n            // We use this when we set YASR results to avoid double JSON parsing and to enforce\n            // using the modified responseJSON. We'll save responseJSON instead (no need to save both).\n            delete dataOrJqXhr.response;\n\n            const executedQueryTabIdx = findTabIndexByID(scope.executedQueryTab.id);\n            const executedQueryTab = scope.tabs[executedQueryTabIdx];\n            const queryResultState = {\n                    queryType: scope.currentTabConfig.queryType,\n                    yasrData: dataOrJqXhr,\n                    textStatus: textStatus,\n                    jqXhrOrErrorString: jqXhrOrErrorString,\n                    page: scope.currentTabConfig.page,\n                    pageSize: scope.currentTabConfig.pageSize,\n                    allResultsCount: scope.currentTabConfig.allResultsCount,\n                    allResultsCountExact: scope.currentTabConfig.allResultsCountExact,\n                    resultsCount: scope.currentTabConfig.resultsCount,\n                    offset: scope.currentTabConfig.offset,\n                    timeTook: scope.currentTabConfig.timeTook,\n                    timeFinished: scope.currentTabConfig.timeFinished,\n                    sizeDelta: scope.currentTabConfig.sizeDelta,\n                    customUpdateMessage: scope.currentTabConfig.customUpdateMessage,\n                    errorMessage: scope.currentTabConfig.errorMessage,\n                    warningMessage: scope.currentTabConfig.warningMessage\n                };\n\n            // Save the output type only if it isn't an update or an ask query.\n            // This way we preserve the existing output type when we execute an update and then\n            // execute a non-ask query.\n            if (scope.currentTabConfig.queryType !== \"ERROR\" && scope.currentTabConfig.queryType !== \"UPDATE\"\n                && scope.currentTabConfig.queryType !== \"ASK\") {\n                queryResultState.outputType = scope.yasr.options.output;\n            }\n\n            // merge query results state with the tab object\n            angular.extend(scope.currentQuery, queryResultState);\n\n            angular.extend(executedQueryTab, queryResultState);\n            if (!scope.nostorage) {\n                LocalStorageAdapter.set(LSKeys.TABS_STATE, scope.tabs);\n            }\n            $('a[data-id = \"' + scope.executedQueryTab.id + '\"]').tab('show');\n        }\n\n        function initYasr() {\n            yasr = YASR(document.getElementById(\"yasr\"), { // eslint-disable-line new-cap\n                getUsedPrefixes: {}, // initially blank, populated when we fetch the namespaces\n                persistency: false\n            });\n            window.yasr = yasr;\n            yasr.afterCopy = afterCopy;\n            yasr.getQueryResultsAsFormat = function (downloadFormat) {\n                // Simple cross-browser download with a form\n                const $wbDownload = $('#wb-download');\n                $wbDownload.attr('action', 'repositories/' + $repositories.getActiveRepository());\n                $('#wb-download-query').val(scope.currentQuery.query);\n                if (window.editor.getValue() !== scope.currentQuery.query) {\n                    toastr.warning('The query in your editor does not match the query results. Download will save the results from the last executed query.');\n                }\n                $('#wb-download-infer').val(scope.currentQuery.inference);\n                $('#wb-download-sameAs').val(scope.currentQuery.sameAs);\n                const auth = localStorage.getItem('com.ontotext.graphdb.auth');\n                if (auth) {\n                    $('#wb-auth-token').val(auth);\n                }\n                $('#wb-download-accept').val(downloadFormat);\n                $wbDownload.submit();\n            };\n            window.editor.options.sparql.handlers.complete = function (dataOrJqXhr, textStatus, jqXhrOrErrorString) {\n                function setNewTabStateForThis() {\n                    setNewTabState(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n                }\n\n                if (connectorProgressModal) {\n                    connectorProgressModal.dismiss('cancel');\n                }\n\n                // If yasqe was destroyed when scope was destroyed, do nothing\n                if (null === window.editor) {\n                    scope.setLoader(false);\n\n                    return;\n                }\n\n                // Extra error/warning through headers\n                scope.currentTabConfig.errorMessage = dataOrJqXhr.getResponseHeader('X-GraphDB-Error');\n                scope.currentTabConfig.warningMessage = dataOrJqXhr.getResponseHeader('X-GraphDB-Warning');\n\n                yasr.currentQuery = scope.currentQuery;\n\n                scope.currentTabConfig.timeFinished = Date.now();\n                scope.currentTabConfig.timeTook = (scope.currentTabConfig.timeFinished - scope.queryStartTime) / 1000;\n\n                if (dataOrJqXhr.status >= 400) {\n                    // Removes useless com.blah.whatever.FooException: ... from the error message\n                    dataOrJqXhr.responseText = dataOrJqXhr.responseText.replace(/^([^: ]+: )+/, '');\n\n                    scope.currentTabConfig.queryType = 'ERROR';\n                    setNewTabStateForThis();\n                    scope.setYasrResponse(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n\n                    scope.setLoader(false);\n\n                    return;\n                }\n\n                if (dataOrJqXhr.status === 0) {\n                    // Query was aborted, typically through window.editor.xhr.abort()\n\n                    scope.currentTabConfig.queryType = 'ERROR';\n\n                    const customError = createCustomError(-1, 'Request was aborted', 'The request has been aborted. There are no results to show.');\n\n                    yasr.results = {\n                        getException: function () {\n                            return customError;\n                        }\n                    };\n\n                    scope.setLoader(false);\n\n                    setNewTabState({customError: customError}, '', null);\n\n                    return;\n                }\n\n                scope.setLoader(false);\n\n                let updateResultsCallback;\n\n                if (window.editor.getQueryMode() === \"update\") {\n                    updateResultsCallback = function () {\n                        RDF4JRepositoriesRestService.getRepositorySize()\n                            .success(function (data) {\n                                let repoSizeDiff;\n                                if (scope.repoSize !== undefined) {\n                                    repoSizeDiff = Number(data) - scope.repoSize;\n                                }\n                                scope.currentTabConfig.sizeDelta = repoSizeDiff;\n                                setNewTabStateForThis();\n                            }).error(function (data) {\n                                toastr.warning('Could not get repository size for: ' + scope.getActiveRepository() + '; ' + getError(data));\n                                scope.currentTabConfig.sizeDelta = undefined;\n                                setNewTabStateForThis();\n                            });\n                    };\n                } else {\n                    if (dataOrJqXhr.status === 200) {\n                        const contentType = dataOrJqXhr.getResponseHeader('Content-Type');\n\n                        if (contentType.indexOf('application/sparql-results+json') === 0\n                            || contentType.indexOf('application/x-sparqlstar-results+json') === 0\n                            || contentType.indexOf('application/x-graphdb-table-results+json') === 0) {\n                            if (dataOrJqXhr.responseJSON.results) {\n                                // SELECT results in one of the standard formats or\n                                // CONSTRUCT or DESCRIBE results in our custom format that looks\n                                // like a SELECT result.\n                                scope.currentTabConfig.resultsCount = dataOrJqXhr.responseJSON.results.bindings.length;\n                                if (dataOrJqXhr.responseJSON.results.bindings.length > scope.currentTabConfig.pageSize) {\n                                    // The results are more than the page size (because we request +1), truncate to page size\n                                    // and raise flag to know we have at least one page more.\n                                    dataOrJqXhr.responseJSON.results.bindings.length = scope.currentTabConfig.pageSize;\n                                }\n                                if (!scope.currentTabConfig.allResultsCountExact) {\n                                    if (scope.nocount || scope.countTimeouted\n                                        || scope.currentTabConfig.resultsCount <= scope.currentTabConfig.pageSize) {\n                                        // No count requested or count timed out or the results are less than the pageSize + 1 buffer\n                                        // In all of these cases it doesn't make sense to run\n                                        // the counting query so we tweak the status to signal that to YASQE.\n                                        dataOrJqXhr.status = 204; // 204 is no content, YASQE counts only if status is 200\n                                    }\n\n                                    // Calculate an \"at least\" all results count, i.e. at least what we have until now + 1.\n                                    // The number will increase when we go to the next page eventually reaching the exact count.\n                                    // A count query may also provide the exact count asynchronously.\n                                    scope.currentTabConfig.allResultsCount = Math.max(scope.currentTabConfig.allResultsCount,\n                                        scope.currentTabConfig.pageSize * (scope.currentTabConfig.page - 1) + scope.currentTabConfig.resultsCount);\n\n                                    // We know we reached the end and the count is exact now.\n                                    if (scope.currentTabConfig.resultsCount <= scope.currentTabConfig.pageSize) {\n                                        scope.currentTabConfig.allResultsCountExact = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    // The following long-running code needs to be in timeout to get the updated loader message\n                    scope.setLoader(true, 'Rendering results', null, true);\n\n                    updateResultsCallback = function () {\n                        scope.setYasrResponse(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n\n                        setNewTabStateForThis();\n                        scope.setLoader(false);\n                    };\n                }\n\n                // By having this in timeout we manage to get the updated loader message\n                $timeout(function () {\n                    updateResultsCallback();\n\n                    // Move disabled class to a, and clean from the li\n                    if (window.editor.getQueryType() !== \"CONSTRUCT\") {\n                        $('.yasr_btnGroup.nav.nav-tabs li a.disabled').removeClass('disabled').css('font-weight', '400');\n                        $('.yasr_btnGroup.nav.nav-tabs li.disabled a').addClass('disabled').css('font-weight', '200');\n                        if (window.editor.getQueryType() === \"DESCRIBE\") {\n                            $('.yasr_btnGroup.nav.nav-tabs li a').removeClass('disabled').css('font-weight', '400');\n                        }\n                    } else if (window.editor.getQueryType() === \"CONSTRUCT\") {\n                        $('.yasr_btnGroup.nav.nav-tabs li a.disabled').removeClass('disabled').css('font-weight', '400');\n                    }\n\n\n                    //Remove paddign of yasr so it will be aligned with sparql editor\n                    $('#yasr').css('padding', '0');\n\n                    if ($('.yasr_btnGroup li:nth-child(2)').hasClass(\"active\")) {\n                        $timeout(function () {\n                            $('.yasr_btnGroup li:nth-child(2) a').get(0).click();\n                        }, 100);\n                    }\n\n                    //\n                    $('#wb-sparql-addNewTab').click(function () {\n                        $('.dataTables_filter').hide();\n                        $('.resultsTable').hide();\n                    });\n                }, 100);\n            };\n\n            window.editor.options.sparql.handlers.resetResults = function () {\n            };\n\n            scope.yasr = yasr;\n\n            scope.setYasrResponse = function(dataOrJqXhr, textStatus, jqXhrOrErrorString) {\n                // If YASR doesn't see a \"response\" property it will parse the textual JSON in \"responseText\".\n                // This is both slow and interferes with the +1 result per page policy when we truncate responseJSON.\n                if (dataOrJqXhr.responseJSON) {\n                    dataOrJqXhr.response = dataOrJqXhr.responseJSON;\n                    dataOrJqXhr.responseText = undefined;\n                }\n                yasr.setResponse(dataOrJqXhr, textStatus, jqXhrOrErrorString);\n            };\n\n            // Track changes in the output type (tab in yasr) so that we can save this together with\n            // the rest of the tab's data.\n            scope.$watch('yasr.options.output', function (value) {\n                // Save the output type only if it isn't an update or an ask query (see comment where we save all properties).\n                if (value && scope.currentTabConfig.queryType !== \"UPDATE\" && scope.currentTabConfig.queryType !== \"ASK\") {\n                    const tab = scope.tabs[findTabIndexByID(scope.currentQuery.id)];\n                    // Do not save tab on default yasr initalization since default table overrides saved value\n                    if (angular.isDefined(tab) && scope.currentTabConfig.queryType) {\n                        if (tab.outputType !== value) {\n                            tab.outputType = scope.currentQuery.outputType = value;\n                            scope.saveTab(tab.id);\n                        }\n                    }\n                }\n            });\n\n            scope.$watch('namespaces', function () {\n                if (scope.namespaces) {\n                    if (yasr && yasr.options && scope.namespaces) {\n                        // this way, the URLs in the results are prettified using the defined prefixes\n                        yasr.options.getUsedPrefixes = scope.namespaces;\n                    }\n\n                    // Notify YASQE about the new namespaces\n                    YASQE.signal(window.editor, 'namespacesChanged', scope.namespaces);\n                }\n            });\n        }\n\n        initYasr();\n\n        function changePagination() {\n            scope.runQuery(true, scope.explainRequested);\n        }\n\n        // Hide the sample queries when the user clicks somewhere else in the UI.\n        $(document).mouseup(function (event) {\n            const container = $('#sampleQueriesCollapse');\n            if (!container.is(event.target) // if the target of the click isn't the container..\n                && container.has(event.target).length === 0 //... nor a descendant of the container\n                && scope.showSampleQueries) {\n                scope.toggleSampleQueries();\n            }\n        });\n\n        function findTabIndexByID(id) {\n            for (let i = 0; i < scope.tabs.length; i++) {\n                const tab = scope.tabs[i];\n                if (tab.id === id) {\n                    return i;\n                }\n            }\n        }\n\n        // functions to load query param or saved queries\n        function toBoolean(v) {\n            return angular.isDefined(v) && v !== 'false';\n        }\n\n        function autoexecuteQueryIfRequested() {\n            const isRequested = toBoolean($location.search().execute);\n\n            if (isRequested) {\n                if (window.editor.getQueryMode() === 'update') {\n                    ModalService.openSimpleModal({\n                        title: 'Confirm execute',\n                        message: 'This is an update and it may change the data in the repository.<br>Are you sure you want to execute it automatically?',\n                        warning: true\n                    }).result\n                        .then(function () {\n                            scope.runQuery(false);\n                        });\n                } else {\n                    scope.runQuery(false);\n                }\n            }\n        }\n\n        function loadQueryIntoExistingOrNewTab(query, infer, sameAs) {\n            const tabId = scope.getExistingTabId(query);\n            // Ah, the joys of non-synchronous events\n            const onHandler = scope.$on('tabLoaded', function () {\n                if (angular.isDefined(infer)) {\n                    scope.currentQuery.inference = toBoolean(infer);\n                }\n                if (angular.isDefined(sameAs)) {\n                    scope.currentQuery.sameAs = toBoolean(sameAs);\n                }\n                autoexecuteQueryIfRequested();\n                onHandler();\n            });\n\n            // See comment about this flag in controller. It's a good idea to be consistent and do this\n            // every time a tab changes without the user clicking on it.\n            scope.highlightNextTabChange = true;\n\n            if (!angular.isDefined(tabId)) {\n                scope.addNewTab(null, query.name, query.body);\n            } else {\n                selectTab(tabId);\n            }\n        }\n\n        function loadSavedQueryIntoExistingOrNewTab(savedQueryName, owner, infer, sameAs) {\n            SparqlRestService.getSavedQuery(savedQueryName, owner)\n                .success(function (data) {\n                    loadQueryIntoExistingOrNewTab(data, infer, sameAs);\n                })\n                .error(function (data) {\n                    toastr.error('Could not get data for saved query: ' + savedQueryName + '; ' + getError(data));\n                });\n        }\n\n        function addTabWithQueryIfNeeded() {\n            if ($location.search().savedQueryName) {\n                // new way\n                loadSavedQueryIntoExistingOrNewTab($location.search().savedQueryName, $location.search().owner,\n                    $location.search().infer, $location.search().sameAs);\n            } else if ($location.search().query) {\n                const query = {name: $location.search().name, body: $location.search().query};\n                loadQueryIntoExistingOrNewTab(query, $location.search().infer, $location.search().sameAs);\n            } else {\n                // Restore the previous tab after the dom has loaded\n                const currentid = LocalStorageAdapter.get(LSKeys.TABS_STATE_CURRENT_ID);\n                selectTab(currentid);\n            }\n        }\n\n        function updateRepositoryAndSecurity() {\n            scope.getNamespaces();\n            YASQE.signal(window.editor, \"repositoryOrAuthorizationChanged\",\n                $repositories.getActiveRepository(), $jwtAuth.getAuthToken());\n            addTabWithQueryIfNeeded();\n        }\n\n        if ($repositories.getActiveRepository()) {\n            updateRepositoryAndSecurity();\n        }\n\n        // When no repo is selected (editor hidden) and the user selects a repo the SPARQL params should be handled\n        scope.$on('repositoryIsSet', function () {\n            if ($repositories.getActiveRepository()) {\n                updateRepositoryAndSecurity();\n            }\n        });\n        // end of repository actions\n\n        // focus the editor\n        $timeout(function () {\n            angular.element(document).find('.CodeMirror textarea:first-child').focus();\n        }, 50);\n\n    }\n}\n"],"sourceRoot":""}