{"version":3,"sources":["webpack:///./src/js/angular/rest/cluster.rest.service.js","webpack:///./src/js/angular/clustermanagement/controllers.js"],"names":["angular","module","factory","ClusterRestService","$inject","CLUSTER_MASTERS_ENDPOINT","$http","getMaster","masterRepositoryID","data","get","configureMaster","master","location","url","encodeURIComponent","method","cloneRepository","post","cloningNodeLocation","currentNodeLocation","cloningNodeRepositoryID","selectedNodeName","newNodeRepositoryID","repositoryID","newNodeLocation","locationUri","newNodeTitle","repositoryTitle","connectWorker","masterLocation","workerLocation","workerURL","disconnectWorker","params","dataType","disconnectNodes","connectNodes","getLocation","node","local","split","ClusterManagementCtrl","$scope","$q","toastr","$repositories","$modal","$sce","$window","$interval","ModalService","$timeout","RepositoriesRestService","setLoader","loader","message","cancel","loaderTimeout","loaderMessage","getLoaderMessage","success","masterInformation","setMasterAttribute","attribute","value","attrData","getLabel","attributeChange","refreshMastersIcons","error","getError","finally","hasInfo","isWorker","locations","getLocations","showCloneModal","clone","selectedNode","name","open","templateUrl","controller","resolve","result","then","cloneCurrentRepository","uri","getNodes","indexOf","substring","source","target","onSuccess","worker","disabledReason","repositoryType","workers","timestamp","Date","now","cluster","push","addOrUpdateLink","peers","connectMasters","disconnectLinkConfirm","d","openSimpleModal","title","warning","disconnectLink","overrideDisabled","$","param","deleteLink","filter","x","masterNodeID","nodeID","peerLocation","peerRepositoryID","peerNodeID","selectNode","$apply","first","second","bidirectional","firstConfigs","secondConfigs","status","key","link","linksHash","reverseKey","reverseLink","links","needsToRestart","updateWarnings","deleteReverse","splice","console","log","needsToRefresh","updateMasterNode","isUpdate","isRandomLink","hasWorkers","masterData","averageReadTime","completedReads","completedWrites","failedReads","failedWrites","pendingWrites","runningReads","runningWrites","readonly","mode","length","forEach","peer","urlToNode","artificiallyAdded","workerNode","fingerprint","averageTaskTime","failedTasks","completedTasks","runningTasks","lastError","trustAsHtml","Math","floor","random","catch","nodes","clusters","getCluster","hasNodes","reduce","type","clusterIdx","mastersData","Object","keys","sort","k1","k2","map","all","_","sortBy","render","trackAddedOrRemovedNodes","uri2tempNode","i","updateClusterIfNeeded","checkNodes","updating","processUpdate","restart","updateStatuses","updateColors","promises","setMode","setReadonly","timerCounter","timer","$on","w","element","resize","bind","unbind","CloneRepositoryCtrl","$modalInstance","copy","ok","patt","RegExp","isInvalidRepoName","test","close","dismiss"],"mappings":"6EAAAA,QACKC,OAAO,yCAA0C,IACjDC,QAAQ,qBAAsBC,GAEnCA,EAAmBC,QAAU,CAAC,SAE9B,MAAMC,EAA2B,uBAEjC,SAASF,EAAmBG,GACxB,MAAO,CACHC,UASJ,SAAmBC,EAAoBC,EAAO,IAC1C,OAAOH,EAAMI,IAAI,GAAGL,KAA4BG,IAAsBC,IATtEE,gBAYJ,SAAyBC,EAAQC,EAAUJ,GACvC,OAAOH,EAAM,CACTQ,IAAK,GAAGT,KAA4BO,oBAAyBG,mBAAmBF,KAChFG,OAAQ,OACRP,UAfJQ,gBAmBJ,SAAyBR,GACrB,OAAOH,EAAMY,KAAK,2BAA4B,CAC1CC,oBAAqBV,EAAKW,oBAC1BC,wBAAyBZ,EAAKa,iBAC9BC,oBAAqBd,EAAKe,aAC1BC,gBAAiBhB,EAAKiB,YACtBC,aAAclB,EAAKmB,mBAxBvBC,cA4BJ,SAAuBjB,EAAQkB,EAAgBC,GAC3C,OAAOzB,EAAM,CACTQ,IAAK,GAAGT,KAA4BO,aACpCI,OAAQ,OACRP,KAAM,CACFuB,UAAWD,EACXD,eAAgBA,MAjCxBG,iBAsCJ,SAA0BrB,EAAQsB,GAC9B,OAAO5B,EAAM,CACTQ,IAAK,GAAGT,KAA4BO,aAAkBsB,IACtDlB,OAAQ,SACRmB,SAAU,UAzCdC,gBA6CJ,SAAyBxB,EAAQsB,GAC7B,OAAO5B,EAAM,CACTQ,IAAK,GAAGT,KAA4BO,WAAgBsB,IACpDlB,OAAQ,SACRmB,SAAU,UAhDdE,aAoDJ,SAAsBzB,EAAQH,GAC1B,OAAOH,EAAM,CACTQ,IAAK,GAAGT,KAA4BO,UACpCI,OAAQ,OACRP,a,gCCxEZ,kBAgBA,SAAS6B,EAAYC,GACjB,OAAIA,EAAKC,MACE,QAEJD,EAAK1B,SAAS4B,MAAM,kBAAkB,GAMjD,SAASC,EAAsBC,EAAQrC,EAAOsC,EAAIC,EAAQC,EAAeC,EAAQC,EAClDC,EAASC,EAAWC,EAAcC,EAAUjD,EAC5CkD,GAE3BV,EAAOW,UAAY,SAAUC,EAAQC,GACjCJ,EAASK,OAAOd,EAAOe,eACnBH,EACAZ,EAAOe,cAAgBN,GAAS,WAC5BT,EAAOY,OAASA,EAChBZ,EAAOgB,cAAgBH,IACxB,KAEHb,EAAOY,QAAS,GAIxBZ,EAAOiB,iBAAmB,WACtB,OAAOjB,EAAOgB,eAAiB,cAGnChB,EAAOpC,UAAY,SAAUC,GACzBL,EAAmBI,UAAUC,GACxBqD,SAAQ,SAAUpD,GACfkC,EAAOmB,kBAAoBrD,MAIvCkC,EAAOoB,mBAAqB,SAAUnD,EAAQoD,EAAWC,GACrD,MAAMC,EAAW,GACjBA,EAASF,GAAaC,EAEtBtB,EAAOW,WAAU,EAAM,wBACvBnD,EAAmBQ,gBAAgBgC,EAAOwB,SAASvD,EAAOC,UAAWyB,EAAY1B,GAASsD,GACrFL,SAAQ,WAIL,OAHAlB,EAAOyB,iBAAkB,EACzBvB,EAAOgB,QAAQ,OAASG,EAAY,OAASC,EAAQ,IAAK,IAC1DtB,EAAO0B,uBACA,KACRC,OAAM,SAAU7D,GAGf,OAFAkC,EAAOyB,iBAAkB,EACzBvB,EAAOyB,MAAMC,SAAS9D,GAAO,2BAA6BuD,IACnD,KACRQ,SAAQ,WACP7B,EAAOW,WAAU,OAI7BX,EAAO8B,QAAU,SAAUlC,GACvB,OAAY,MAARA,IAGAI,EAAO+B,SAASnC,GACT,gBAAiBA,EAEjB,gBAAiBA,IAIhCI,EAAOgC,UAAY,WACf,OAAO7B,EAAc8B,gBAGzBjC,EAAOkC,eAAiB,WACpBlC,EAAOmC,MAAMH,UAAYhC,EAAOgC,YAChChC,EAAOmC,MAAMtD,aAAemB,EAAOoC,aAAaC,KAC1BjC,EAAOkC,KAAK,CAC9BC,YAAa,gEACbC,WAAY,sBACZC,QAAS,CACLN,MAAO,WACH,OAAOnC,EAAOmC,UAIZO,OAAOC,MAAK,SAAUR,GAChCnC,EAAOmC,MAAQA,EACfnC,EAAO4C,4BACR,WACC5C,EAAOoC,aAAe,SAI9BpC,EAAO4C,uBAAyB,WAC5B,MAAMnE,EAAsBkB,EAAYK,EAAOoC,cAE/CpC,EAAOW,WAAU,EAAM,qBAEvBnD,EAAmBc,gBAAgB,CAC/BG,oBAAqBA,EACrBE,iBAAkBqB,EAAOoC,aAAaC,KACtCxD,aAAcmB,EAAOmC,MAAMtD,aAC3BE,YAAaiB,EAAOmC,MAAMjE,SAAS2E,IACnC5D,gBAAiBe,EAAOmC,MAAMlD,kBAC/BiC,SAAQ,WACPhB,EAAOgB,QAAQ,oBAAsBlB,EAAOmC,MAAMjE,UAClD8B,EAAO8C,cACRnB,OAAM,SAAU7D,GACfoC,EAAOyB,MAAMC,SAAS9D,GAAO,yBAC9B+D,SAAQ,WACP7B,EAAOW,WAAU,OAIzBX,EAAOwB,SAAW,SAAUrD,GACxB,OAA4B,IAAxBA,EAAI4E,QAAQ,QACLV,KAEJlE,EAAI6E,UAAU7E,EAAI4E,QAAQ,iBAAmB,KAOxD/C,EAAON,aAAe,SAAUuD,EAAQC,EAAQC,GAC5C,IAAIlF,EACAmF,EAEJ,GAAI,mBAAoBH,EACpB/C,EAAOyB,MAAMsB,EAAOI,eAAgB,cAIxC,GAAI,mBAAoBH,EACpBhD,EAAOyB,MAAMuB,EAAOG,eAAgB,cAIxC,GAA8B,WAA1BJ,EAAOK,gBAAyD,WAA1BJ,EAAOI,eAAjD,CAWO,GAA8B,WAA1BL,EAAOK,eACdrF,EAASgF,EACTG,EAASF,MACN,IAA8B,WAA1BA,EAAOI,eAKd,YADApD,EAAOyB,MAAM,iCAAkC,SAH/C1D,EAASiF,EACTE,EAASH,EAMTG,EAAOlF,YAAYD,EAAOsF,QAC1BrD,EAAOyB,MAAM,0CAA2C,UAI5D3B,EAAOW,WAAU,EAAM,uBAEvBnD,EAAmB0B,cAAcc,EAAOwB,SAASvD,EAAOC,UAAWyB,EAAY1B,GAASmF,EAAOlF,UAC1FgD,SAAQ,WACL,MAAMsC,EAAYC,KAAKC,MAEvBN,EAAOO,QAAUP,EAAOO,SAAW,GACnCP,EAAOO,QAAQC,KAAK3F,EAAO0F,SAE3B3D,EAAO6D,gBAAgB5F,EAAQmF,EAAQ,GAAII,GAE3CvF,EAAOsF,QAAQH,EAAOlF,UAAY,EAElCiF,IAEAjD,EAAOgB,QAAQ,8BAA+B,OAC/CS,OAAM,SAAU7D,GACfoC,EAAOyB,MAAMC,SAAS9D,GAAO,8BAC9B+D,SAAQ,WACP7B,EAAOW,WAAU,YA7CjBsC,EAAO/E,YAAYgF,EAAOY,OAASZ,EAAOhF,YAAY+E,EAAOa,MAC7D5D,EAAOyB,MAAM,4BAA6B,SACnCsB,EAAO/E,YAAYgF,EAAOY,MACjC9D,EAAO+D,eAAed,EAAQC,GAAQ,EAAOC,GACtCD,EAAOhF,YAAY+E,EAAOa,MACjC9D,EAAO+D,eAAeb,EAAQD,GAAQ,EAAOE,GAE7CnD,EAAO+D,eAAed,EAAQC,GAAQ,EAAMC,IA0CxDnD,EAAOgE,sBAAwB,SAAUC,EAAGd,GACxC3C,EAAa0D,gBAAgB,CACzBC,MAAO,qBACPtD,QAAS,iDACTuD,SAAS,IACV1B,OACEC,MAAK,WACF3C,EAAOqE,eAAeJ,EAAGd,OAkDrCnD,EAAOqE,eAAiB,SAAUJ,EAAGd,EAAWmB,GAC5C,IAAIrG,EAAS,GACTmF,EAAS,GACmB,WAA5Ba,EAAEhB,OAAOK,gBACTrF,EAASgG,EAAEhB,OACXG,EAASa,EAAEf,QACwB,WAA5Be,EAAEf,OAAOI,iBAChBrF,EAASgG,EAAEf,OACXE,EAASa,EAAEhB,QAGVqB,KAAqB,mBAAoBrG,GAAoC,WAA1BmF,EAAOE,gBAA+B,mBAAoBF,IAclHpD,EAAOW,WAAU,EAAM,0BAEO,WAA1ByC,EAAOE,eAzEf,SAA0BW,EAAGhG,EAAQmF,EAAQD,GACzC3F,EAAmB8B,iBAAiBU,EAAOwB,SAASvD,EAAOC,UAAWqG,EAAEC,MAAM,CAC1EnF,UAAW+D,EAAOlF,SAClBiB,eAAgBQ,EAAY1B,MAC5BiD,SAAQ,WACRlB,EAAOyE,WAAWR,GAElBb,EAAOO,QAAUP,EAAOO,QAAQe,QAAO,SAAUC,GAC7C,OAAOA,IAAM1G,EAAO0F,kBAGjB1F,EAAOsF,QAAQH,EAAOlF,UAE7BiF,IAEAjD,EAAOgB,QAAQ,mCAAoC,OACpDS,OAAM,SAAU7D,GACfoC,EAAOyB,MAAMC,SAAS9D,GAAO,iCAC9B+D,SAAQ,WACP7B,EAAOW,WAAU,MAuDjBrB,CAAiB2E,EAAGhG,EAAQmF,EAAQD,GAnD5C,SAAyBc,EAAGhG,EAAQmF,EAAQD,GACxC3F,EAAmBiC,gBAAgBO,EAAOwB,SAASvD,EAAOC,UAAWqG,EAAEC,MAAM,CACzErF,eAAgBQ,EAAY1B,GAC5B2G,aAAc3G,EAAO4G,OACrBC,aAAcnF,EAAYyD,GAC1B2B,iBAAkB/E,EAAOwB,SAAS4B,EAAOlF,UACzC8G,WAAY5B,EAAOyB,UACnB3D,SAAQ,SAAUpD,GAClBkC,EAAOyE,WAAWR,GAAG,UAEdb,EAAOU,MAAM7F,EAAOC,iBACpBD,EAAO6F,MAAMV,EAAOlF,UAE3BiF,IAEAjD,EAAOgB,QAAQpD,EAAM,OACtB6D,OAAM,SAAU7D,GACfoC,EAAOyB,MAAMC,SAAS9D,GAAO,kCAC9B+D,SAAQ,WACP7B,EAAOW,WAAU,MAmCjBlB,CAAgBwE,EAAGhG,EAAQmF,EAAQD,IAnBnC3C,EAAa0D,gBAAgB,CACzBC,MAAO,qBACPtD,QAAS,yJAETuD,SAAS,IACV1B,OACEC,MAAK,WACF3C,EAAOqE,eAAeJ,EAAGd,GAAW,OAiBpDnD,EAAOiF,WAAa,SAAUrF,GACtBI,EAAOoC,eAAiBxC,EACxBI,EAAOoC,aAAexC,EAEtBI,EAAOoC,aAAe,KAE1BpC,EAAOkF,UAGXlF,EAAO+B,SAAW,SAAUnC,GACxB,OAAOA,SAA+D,WAAxBA,EAAK0D,gBAGvDtD,EAAO+D,eAAiB,SAAUoB,EAAOC,EAAQC,EAAelC,GAC5D,MAAMmC,EAAeH,EAAMjH,SAAS4B,MAAM,kBACpCyF,EAAgBH,EAAOlH,SAAS4B,MAAM,kBAE5CE,EAAOW,WAAU,EAAM,uBAEvBnD,EAAmBkC,aAAa4F,EAAa,GAAI,CAC7CnG,eAAgBgG,EAAMtF,MAAQ,QAAUyF,EAAa,GACrDV,aAAcO,EAAMN,OACpBC,aAAcM,EAAOvF,MAAQ,QAAU0F,EAAc,GACrDR,iBAAkBQ,EAAc,GAChCP,WAAYI,EAAOP,OACnBQ,cAAeA,IAChBnE,SAAQ,SAAUpD,GAEjB,MAAM0F,EAAYC,KAAKC,MAEvB1D,EAAO6D,gBAAgBsB,EAAOC,EAAQ,KAAM5B,GAC5C2B,EAAMrB,MAAMsB,EAAOlH,UAAY,EAE3BmH,IACAD,EAAOtB,MAAMqB,EAAMjH,UAAY,EAC/B8B,EAAO6D,gBAAgBuB,EAAQD,EAAO,KAAM3B,IAGhDL,IAEAjD,EAAOgB,QAAQpD,EAAM,OACtB6D,OAAM,SAAU7D,GACfoC,EAAOyB,MAAMC,SAAS9D,GAAO,+BAC9B+D,SAAQ,WACP7B,EAAOW,WAAU,OAIzBX,EAAO6D,gBAAkB,SAAUZ,EAAQC,EAAQsC,EAAQhC,GACvD,MAAMiC,EAAMxC,EAAO/E,SAAW,IAAMgF,EAAOhF,SAC3C,IAAIwH,EAAO1F,EAAO2F,UAAUF,GAC5B,MAAMG,EAAa1C,EAAOhF,SAAW,IAAM+E,EAAO/E,SAC5C2H,EAAc7F,EAAO2F,UAAUC,GA0BrC,OAzBKF,IAEDA,EAAO,GACP1F,EAAO2F,UAAUF,GAAOC,EACxB1F,EAAO8F,MAAMlC,KAAK8B,GAClBA,EAAa,OAAIzC,EACjByC,EAAa,OAAIxC,EACjBlD,EAAO+F,gBAAiB,GAK5BL,EAAa,OAAIF,EACjBE,EAAgB,UAAIlC,EAEpBkC,EAAyB,mBAA8B,WAA1BzC,EAAOK,gBAAyD,WAA1BJ,EAAOI,iBAAgCuC,EACtGA,GAAeA,EAAgC,qBAC/CA,EAAgC,oBAAI,GAExC7F,EAAO2F,UAAUF,GAAOC,EAEpB1F,EAAOgG,gBACPhG,EAAOgG,iBAGJN,GAGX1F,EAAOyE,WAAa,SAAUiB,EAAMO,GAChCjG,EAAO8F,MAAMI,OAAOlG,EAAO8F,MAAM/C,QAAQ2C,GAAO,GAChD,MAAMD,EAAMC,EAAKzC,OAAO/E,SAAW,IAAMwH,EAAKxC,OAAOhF,SAQrD,UAPO8B,EAAO2F,UAAUF,IACpBC,EAAKzC,OAAOI,gBAAkBqC,EAAKxC,OAAOG,kBAE1C8C,QAAQC,IAAI,uCACZpG,EAAOqG,gBAAiB,GAGxBJ,EAAe,CACf,MAAML,EAAaF,EAAKxC,OAAOhF,SAAW,IAAMwH,EAAKzC,OAAO/E,SACtD2H,EAAc7F,EAAO2F,UAAUC,GACjCC,GACA7F,EAAOyE,WAAWoB,GAAa,KAK3C7F,EAAOsG,iBAAmB,SAAU1G,EAAM4D,EAAW+C,EAAUC,GAC3D,OAAOhJ,EAAmBI,UAAUgC,EAAKyC,KAAM,CAC3C9C,OAAQ,CACJJ,eAAgBQ,EAAYC,MAG/B+B,OAAM,SAAU7D,GAiBb,MAhB0B,iCAEtB8B,EAAKyD,iBAELnD,EAAOyB,MAAMC,SAAS9D,GAAO,0BAA4B8B,EAAKyC,MAE9DzC,EAAKyD,eANiB,+BAStBzD,EAAKkE,MAAQ,GACblE,EAAK2D,QAAU,GACf3D,EAAK6G,YAAa,GAGtB7G,EAAK4D,UAAYA,GAEV,KAEVtC,SAAQ,SAAUwF,GACf9G,EAAK+G,gBAAkBD,EAAWC,gBAClC/G,EAAKgH,eAAiBF,EAAWE,eACjChH,EAAKiH,gBAAkBH,EAAWG,gBAClCjH,EAAKkH,YAAcJ,EAAWI,YAC9BlH,EAAKmH,aAAeL,EAAWK,aAC/BnH,EAAKoH,cAAgBN,EAAWM,cAChCpH,EAAKqH,aAAeP,EAAWO,aAC/BrH,EAAKsH,cAAgBR,EAAWQ,cAChCtH,EAAKuH,SAAWT,EAAWS,SAC3BvH,EAAKwH,KAAOV,EAAWU,KACvBxH,EAAKiF,OAAS6B,EAAW7B,OACzBjF,EAAKkE,MAAQ,GACblE,EAAK2D,QAAU,GACf3D,EAAK4D,UAAYA,EACjB5D,EAAK6G,WAAaC,EAAWnD,QAAQ8D,OAAS,EAE9CX,EAAW5C,MAAMwD,SAAQ,SAAUC,GAC/B3H,EAAKkE,MAAMyD,EAAKrJ,UAAY,EACtBqJ,EAAKrJ,YAAY8B,EAAOwH,YAEtBjB,GACAJ,QAAQC,IAAI,kCACZpG,EAAOqG,gBAAiB,GAGxBrG,EAAOwH,UAAUD,EAAKrJ,UAAY,CAC9BmE,KAAMrC,EAAOwB,SAAS+F,EAAKrJ,UAC3BmF,eAAgB,4EAChBnF,SAAUqJ,EAAKrJ,SACf2G,OAAQ0C,EAAK1C,OACbvB,eAAgB,SAChBmE,mBAAmB,IAM/BzH,EAAO6D,gBAAgBjE,EAAMI,EAAOwH,UAAUD,EAAKrJ,UAAW,KAAMsF,MAGxEkD,EAAWnD,QAAQ+D,SAAQ,SAAUlE,GACjCxD,EAAK2D,QAAQH,EAAOlF,UAAY,EAChC,IAAIwJ,EAAa,GACjB,GAAItE,EAAOlF,YAAY8B,EAAOwH,UAC1BE,EAAa1H,EAAOwH,UAAUpE,EAAOlF,cAClC,CAEH,GAAIqI,EAGA,OAFAJ,QAAQC,IAAI,uCACZpG,EAAOqG,gBAAiB,GAGxBqB,EAAa1H,EAAOwH,UAAUpE,EAAOlF,UAAY,CAC7CmE,KAAMrC,EAAOwB,SAAS4B,EAAOlF,UAC7BA,SAAUkF,EAAOlF,SACjBoF,eAAgB,SAChBmE,mBAAmB,GAK/BC,EAAWC,YAAcvE,EAAOuE,YAChCD,EAAWE,gBAAkBxE,EAAOwE,gBACpCF,EAAWG,YAAczE,EAAOyE,YAChCH,EAAWI,eAAiB1E,EAAO0E,eACnCJ,EAAWK,aAAe3E,EAAO2E,aACjCL,EAAWlE,UAAYA,EAEnBkE,EAAWD,mBACXC,EAAWrE,eAAiB,mDACxBD,EAAO4E,YACPN,EAAWrE,gBAAkB,OAASD,EAAO4E,YAE1C5E,EAAO4E,UACdN,EAAWrE,eAAiBD,EAAO4E,iBAE5BN,EAAWrE,eAGlBqE,EAAWrE,iBACXqE,EAAWrE,eAAiBhD,EAAK4H,YAAYP,EAAWrE,iBAG5DqE,EAAW/D,QAAU+D,EAAW/D,SAAW,IACO,IAA9C+D,EAAW/D,QAAQZ,QAAQnD,EAAK+D,UAChC+D,EAAW/D,QAAQC,KAAKhE,EAAK+D,SAGjC,IAAI6B,EAASpC,EAAOoC,OAGhBgB,IACAhB,EAAS,CAAC,gBAAiB,KAAM,MAAO,qBAAsB,qBAC1D,cAAe,qBAAsB,gBAAiB,WAAW0C,KAAKC,MAAsB,EAAhBD,KAAKE,YAIzFpI,EAAO6D,gBAAgBjE,EAAMI,EAAOwH,UAAUpE,EAAOlF,UAAWsH,EAAQhC,SAE7E6E,OAAM,WACL,OAAO,MAInBrI,EAAO8C,SAAW,WAWd,OATA9C,EAAOsI,MAAQ,GACftI,EAAO8F,MAAQ,GACf9F,EAAO2F,UAAY,GACnB3F,EAAOmC,MAAQ,GACfnC,EAAOoC,aAAe,KACtBpC,EAAOuI,SAAW,GAElBvI,EAAOW,WAAU,GAEVD,EAAwB8H,aAC1BtH,SAAQ,SAAUpD,GACfkC,EAAOyI,SAAW3K,EAAKuJ,OAAS,EAChCrH,EAAO8F,MAAQ,GACf9F,EAAO2F,UAAY,GACnB3F,EAAOuI,SAAW,GAElB,MAAM/E,EAAYC,KAAKC,MAEvB1D,EAAOwH,UAAY1J,EAAK4K,QAAO,SAAUhG,EAAQ9C,GAU7C,MATkB,WAAdA,EAAK+I,MAAmC,WAAd/I,EAAK+I,OAC/BjG,EAAO9C,EAAKiD,KAAO,CACfR,KAAMrC,EAAOwB,SAAS5B,EAAKiD,KAC3BhD,MAAOD,EAAKC,MACZ3B,SAAU0B,EAAKiD,IACfS,eAAgB1D,EAAK+I,KACrBnF,UAAWA,IAGZd,IACR,IAEH,IAAIkG,EAAa,EAEjB,MAAMC,EAAcC,OAAOC,KAAK/I,EAAOwH,WAAW9C,QAAO,SAAUe,GAC/D,MAAgD,WAAzCzF,EAAOwH,UAAU/B,GAAKnC,kBAC9B0F,MAAK,SAAUC,EAAIC,GAClB,OAAID,EAAKC,GACG,EACDD,EAAKC,EACL,EAGJ,KACRC,KAAI,SAAU1D,GACb,MAAM7F,EAAOI,EAAOwH,UAAU/B,GAK9B,OAHA7F,EAAK+D,QAAUiF,EACf5I,EAAOuI,SAAS3E,KAAKhE,GACrBgJ,IACO5I,EAAOsG,iBAAiB1G,EAAM4D,MAGzC,OAAOvD,EAAGmJ,IAAIP,GAAahH,SAAQ,WAC/B7B,EAAOsI,MAAQe,EAAEC,OACbR,OAAOC,KAAK/I,EAAOwH,WAAW2B,KAAI,SAAU1D,GACxC,OAAOzF,EAAOwH,UAAU/B,MAE5B,CAAC,SAGLzF,EAAOuJ,SAEPvJ,EAAOW,WAAU,SAIxBgB,OAAM,SAAU7D,GACbkC,EAAOyI,UAAW,EAClBvI,EAAOyB,MAAMC,SAAS9D,GAAO,uBAC7BkC,EAAOW,WAAU,MAEpBkB,SAAQ,WACL7B,EAAOqG,gBAAiB,MAIpCrG,EAAOwJ,yBAA2B,SAAUhG,GACxC,OAAO9C,EAAwB8H,aAC1BtH,SAAQ,SAAUpD,GACf,MAAM2L,EAAe3L,EAAK4K,QAAO,SAAUhG,EAAQ9C,GAO/C,MANkB,WAAdA,EAAK+I,MAAmC,WAAd/I,EAAK+I,OAC/BjG,EAAO9C,EAAKiD,KAAO,CACf3E,SAAU0B,EAAKiD,IACfS,eAAgB1D,EAAK+I,OAGtBjG,IACR,IAEH,IAAK,IAAIgH,EAAI,EAAGA,EAAI1J,EAAOsI,MAAMjB,OAAQqC,IAAK,CAC1C,MAAM9J,EAAOI,EAAOsI,MAAMoB,GAC1B,GAAI9J,EAAK1B,YAAYuL,EACZ7J,EAAK6H,oBAEN7H,EAAK4D,UAAYA,SACViG,EAAa7J,EAAK1B,gBAE1B,IAAK0B,EAAK6H,kBAIb,OAFAtB,QAAQC,IAAI,iCACZpG,EAAOqG,gBAAiB,GACjB,EAIXyC,OAAOC,KAAKU,GAAcpC,OAAS,IAEnClB,QAAQC,IAAI,+BACZpG,EAAOqG,gBAAiB,MAG/B1E,OAAM,SAAU7D,GACboC,EAAOyB,MAAMC,SAAS9D,GAAO,2BAIzCkC,EAAO2J,sBAAwB,SAAUC,GAErC5J,EAAO6J,UAAW,EAElB,MAAMrG,EAAYC,KAAKC,MAEjBoG,EAAgB,WAClB,IAAK9J,EAAOqG,eAER,IAAK,IAAIqD,EAAI,EAAGA,EAAI1J,EAAO8F,MAAMuB,OAAQqC,IAAK,CAC1C,MAAMhE,EAAO1F,EAAO8F,MAAM4D,GACtBhE,EAAgB,YAAMlC,IACtB2C,QAAQC,IAAI,qCAIZpG,EAAOyE,WAAWiB,GAAM,IAKhC1F,EAAOqG,gBAEPF,QAAQC,IAAI,qBACZpG,EAAO8C,YACA9C,EAAO+F,gBAEdI,QAAQC,IAAI,kCACZpG,EAAO+J,YAGP/J,EAAOgK,iBAEPhK,EAAOiK,eAEPjK,EAAOgG,iBAEPhG,EAAO6J,UAAW,IAI1B,GAAID,EACA5J,EAAOwJ,yBAAyBhG,GAAWb,MAAK,WAC5C,GAAK3C,EAAOqG,eAURyD,QAVwB,CACxB,MAAMI,EAAW,GACjB,IAAK,IAAIR,EAAI,EAAGA,EAAI1J,EAAOsI,MAAMjB,OAAQqC,IAAK,CAC1C,MAAM9J,EAAOI,EAAOsI,MAAMoB,GACE,WAAxB9J,EAAK0D,gBACL4G,EAAStG,KAAK5D,EAAOsG,iBAAiB1G,EAAM4D,GAAW,IAG/DvD,EAAGmJ,IAAIc,GAAUrI,QAAQiI,WAK9B,CACH,MAAMI,EAAW,GACjB,IAAK,IAAIR,EAAI,EAAGA,EAAI1J,EAAOsI,MAAMjB,OAAQqC,IAAK,CAC1C,MAAM9J,EAAOI,EAAOsI,MAAMoB,GACE,WAAxB9J,EAAK0D,gBACL4G,EAAStG,KAAK5D,EAAOsG,iBAAiB1G,EAAM4D,GAAW,IAG/DvD,EAAGmJ,IAAIc,GAAUrI,QAAQiI,KAIjC9J,EAAO8C,WAEP9C,EAAOmK,QAAU,SAAU/C,GACvBpH,EAAOyB,iBAAkB,EACzBzB,EAAOoB,mBAAmBpB,EAAOoC,aAAc,OAAQgF,IAG3DpH,EAAOoK,YAAc,SAAUjD,GAC3BnH,EAAOyB,iBAAkB,EACzBzB,EAAOoC,aAAa+E,SAAWA,EAC/BnH,EAAOoB,mBAAmBpB,EAAOoC,aAAc,WAAY+E,IAG/D,IAAIkD,EAAe,EACnB,MAAMC,EAAQ/J,GAAU,WAEfP,EAAOyB,iBAAoBzB,EAAO6J,WACnCQ,IAEArK,EAAO2J,sBAAsBU,EAAe,GAAM,MAEvD,KAEHrK,EAAOuK,IAAI,YAAY,WACnBhK,EAAUO,OAAOwJ,MAGrBtK,EAAOyB,iBAAkB,EACzBzB,EAAO6J,UAAW,EAGlB,MAAMW,EAAInN,QAAQoN,QAAQnK,GACpBoK,EAAS,WACX1K,EAAO0K,UAEXF,EAAEG,KAAK,SAAUD,GACjB1K,EAAOuK,IAAI,YAAY,WACnBC,EAAEI,OAAO,SAAUF,MAIvB1K,EAAOuK,IAAI,oBAAoB,WAC3BvK,EAAO0K,YAMf,SAASG,EAAoB7K,EAAQ8K,EAAgB3I,GAEjDnC,EAAOmC,MAAQ9E,QAAQ0N,KAAK5I,GAC5BnC,EAAOgL,GAAK,WACR,MAAMC,EAAO,IAAIC,OAAO,oBACxBlL,EAAOmL,mBAAqBF,EAAKG,KAAKpL,EAAOmC,MAAMtD,cAC9CmB,EAAOmL,mBACRL,EAAeO,MAAMrL,EAAOmC,QAIpCnC,EAAOc,OAAS,WACZgK,EAAeQ,QAAQ,WA1vB/BjO,QACKC,OAAO,kDATI,CACZ,eACA,+CACA,8CACA,yCACA,WAKCkF,WAAW,wBAAyBzC,GACpCyC,WAAW,sBAAuBqI,GASvC9K,EAAsBtC,QAAU,CAAC,SAAU,QAAS,KAAM,SAAU,gBAAiB,SAAU,OAC3F,UAAW,YAAa,eAAgB,WAAY,qBAAsB,2BA+tB9EoN,EAAoBpN,QAAU,CAAC,SAAU,iBAAkB","file":"7.a4a2cbe99f4433279558.bundle.js","sourcesContent":["angular\n    .module('graphdb.framework.rest.cluster.service', [])\n    .factory('ClusterRestService', ClusterRestService);\n\nClusterRestService.$inject = ['$http'];\n\nconst CLUSTER_MASTERS_ENDPOINT = 'rest/cluster/masters';\n\nfunction ClusterRestService($http) {\n    return {\n        getMaster,\n        configureMaster,\n        cloneRepository,\n        connectWorker,\n        disconnectWorker,\n        disconnectNodes,\n        connectNodes\n    };\n\n    function getMaster(masterRepositoryID, data = {}) {\n        return $http.get(`${CLUSTER_MASTERS_ENDPOINT}/${masterRepositoryID}`, data);\n    }\n\n    function configureMaster(master, location, data) {\n        return $http({\n            url: `${CLUSTER_MASTERS_ENDPOINT}/${master}?masterLocation=${encodeURIComponent(location)}`,\n            method: 'POST',\n            data\n        });\n    }\n\n    function cloneRepository(data) {\n        return $http.post('rest/cluster/nodes/clone', {\n            cloningNodeLocation: data.currentNodeLocation,\n            cloningNodeRepositoryID: data.selectedNodeName,\n            newNodeRepositoryID: data.repositoryID,\n            newNodeLocation: data.locationUri,\n            newNodeTitle: data.repositoryTitle\n        })\n    }\n\n    function connectWorker(master, masterLocation, workerLocation) {\n        return $http({\n            url: `${CLUSTER_MASTERS_ENDPOINT}/${master}/workers/`,\n            method: 'POST',\n            data: {\n                workerURL: workerLocation,\n                masterLocation: masterLocation\n            }\n        })\n    }\n\n    function disconnectWorker(master, params) {\n        return $http({\n            url: `${CLUSTER_MASTERS_ENDPOINT}/${master}/workers?${params}`,\n            method: 'DELETE',\n            dataType: 'text'\n        });\n    }\n\n    function disconnectNodes(master, params) {\n        return $http({\n            url: `${CLUSTER_MASTERS_ENDPOINT}/${master}/peers?${params}`,\n            method: 'DELETE',\n            dataType: 'text'\n        });\n    }\n\n    function connectNodes(master, data) {\n        return $http({\n            url: `${CLUSTER_MASTERS_ENDPOINT}/${master}/peers`,\n            method: 'POST',\n            data\n        });\n    }\n}\n","import 'angular/core/services';\nimport 'angular/rest/cluster.rest.service';\n\nconst modules = [\n    'ui.bootstrap',\n    'graphdb.framework.core.services.repositories',\n    'graphdb.framework.rest.repositories.service',\n    'graphdb.framework.rest.cluster.service',\n    'toastr'\n];\n\nangular\n    .module('graphdb.framework.clustermanagement.controllers', modules)\n    .controller('ClusterManagementCtrl', ClusterManagementCtrl)\n    .controller('CloneRepositoryCtrl', CloneRepositoryCtrl);\n\nfunction getLocation(node) {\n    if (node.local) {\n        return 'local';\n    }\n    return node.location.split('/repositories/')[0];\n}\n\nClusterManagementCtrl.$inject = ['$scope', '$http', '$q', 'toastr', '$repositories', '$modal', '$sce',\n    '$window', '$interval', 'ModalService', '$timeout', 'ClusterRestService', 'RepositoriesRestService'];\n\nfunction ClusterManagementCtrl($scope, $http, $q, toastr, $repositories, $modal, $sce,\n                               $window, $interval, ModalService, $timeout, ClusterRestService,\n                               RepositoriesRestService) {\n    // TODO: Similar function is declared multiple times in different components. Find out how to avoid it!\n    $scope.setLoader = function (loader, message) {\n        $timeout.cancel($scope.loaderTimeout);\n        if (loader) {\n            $scope.loaderTimeout = $timeout(function () {\n                $scope.loader = loader;\n                $scope.loaderMessage = message;\n            }, 300);\n        } else {\n            $scope.loader = false;\n        }\n    };\n\n    $scope.getLoaderMessage = function () {\n        return $scope.loaderMessage || 'Loading...';\n    };\n\n    $scope.getMaster = function (masterRepositoryID) {\n        ClusterRestService.getMaster(masterRepositoryID)\n            .success(function (data) {\n                $scope.masterInformation = data;\n            });\n    };\n\n    $scope.setMasterAttribute = function (master, attribute, value) {\n        const attrData = {};\n        attrData[attribute] = value;\n\n        $scope.setLoader(true, 'Setting attribute...');\n        ClusterRestService.configureMaster($scope.getLabel(master.location), getLocation(master), attrData)\n            .success(function () {\n                $scope.attributeChange = false;\n                toastr.success(\"Set \" + attribute + \" to \" + value + \".\", \"\");\n                $scope.refreshMastersIcons();\n                return true;\n            }).error(function (data) {\n                $scope.attributeChange = false;\n                toastr.error(getError(data), \"Error setting attribute \" + attribute);\n                return true;\n            }).finally(function () {\n                $scope.setLoader(false);\n            });\n    };\n\n    $scope.hasInfo = function (node) {\n        if (node == null) {\n            return true;\n        }\n        if ($scope.isWorker(node)) {\n            return 'fingerprint' in node;\n        } else {\n            return 'failedReads' in node;\n        }\n    };\n\n    $scope.locations = function () {\n        return $repositories.getLocations();\n    };\n\n    $scope.showCloneModal = function () {\n        $scope.clone.locations = $scope.locations();\n        $scope.clone.repositoryID = $scope.selectedNode.name;\n        const modalInstance = $modal.open({\n            templateUrl: 'js/angular/clustermanagement/templates/modal/clone-modal.html',\n            controller: 'CloneRepositoryCtrl',\n            resolve: {\n                clone: function () {\n                    return $scope.clone;\n                }\n            }\n        });\n        modalInstance.result.then(function (clone) {\n            $scope.clone = clone;\n            $scope.cloneCurrentRepository();\n        }, function () {\n            $scope.selectedNode = null;\n        });\n    };\n\n    $scope.cloneCurrentRepository = function () {\n        const currentNodeLocation = getLocation($scope.selectedNode);\n\n        $scope.setLoader(true, 'Cloning worker...');\n\n        ClusterRestService.cloneRepository({\n            currentNodeLocation: currentNodeLocation,\n            selectedNodeName: $scope.selectedNode.name,\n            repositoryID: $scope.clone.repositoryID,\n            locationUri: $scope.clone.location.uri,\n            repositoryTitle: $scope.clone.repositoryTitle\n        }).success(function () {\n            toastr.success('Cloned node into ' + $scope.clone.location);\n            $scope.getNodes();\n        }).error(function (data) {\n            toastr.error(getError(data), \"Error cloning node\");\n        }).finally(function () {\n            $scope.setLoader(false);\n        });\n    };\n\n    $scope.getLabel = function (url) {\n        if (url.indexOf(\"http\") !== 0) {\n            return name;\n        }\n        return url.substring(url.indexOf('/repositories') + 14);\n    };\n\n    /**\n     * Creates a link between two nodes. That this function abstracts away\n     * if firstNode is a master or it's secondNode\n     */\n    $scope.connectNodes = function (source, target, onSuccess) {\n        let master;\n        let worker;\n\n        if ('disabledReason' in source) {\n            toastr.error(source.disabledReason, \"Error\");\n            return;\n        }\n\n        if ('disabledReason' in target) {\n            toastr.error(target.disabledReason, \"Error\");\n            return;\n        }\n\n        if (source.repositoryType === 'master' && target.repositoryType === 'master') {\n            if (source.location in target.peers && target.location in source.peers) {\n                toastr.error(\"Masters already connected\", \"Error\");\n            } else if (source.location in target.peers) {\n                $scope.connectMasters(source, target, false, onSuccess);\n            } else if (target.location in source.peers) {\n                $scope.connectMasters(target, source, false, onSuccess);\n            } else {\n                $scope.connectMasters(source, target, true, onSuccess);\n            }\n            return;\n        } else if (source.repositoryType === 'master') {\n            master = source;\n            worker = target;\n        } else if (target.repositoryType === 'master') {\n            master = target;\n            worker = source;\n        } else {\n            toastr.error(\"You cannot connect two workers\", \"Error\");\n            return;\n        }\n\n        if (worker.location in master.workers) {\n            toastr.error(\"Worker already connected to that master\", \"Error\");\n            return;\n        }\n\n        $scope.setLoader(true, 'Connecting nodes...');\n\n        ClusterRestService.connectWorker($scope.getLabel(master.location), getLocation(master), worker.location)\n            .success(function () {\n                const timestamp = Date.now();\n\n                worker.cluster = worker.cluster || [];\n                worker.cluster.push(master.cluster);\n\n                $scope.addOrUpdateLink(master, worker, '', timestamp);\n\n                master.workers[worker.location] = 1;\n\n                onSuccess();\n\n                toastr.success(\"Connected worker to master.\", \"\");\n            }).error(function (data) {\n                toastr.error(getError(data), \"Error connecting worker\");\n            }).finally(function () {\n                $scope.setLoader(false);\n            });\n    };\n\n    $scope.disconnectLinkConfirm = function (d, onSuccess) {\n        ModalService.openSimpleModal({\n            title: 'Confirm disconnect',\n            message: 'Are you sure you want to disconnect the nodes?',\n            warning: true\n        }).result\n            .then(function () {\n                $scope.disconnectLink(d, onSuccess);\n            });\n    };\n\n    function disconnectWorker(d, master, worker, onSuccess) {\n        ClusterRestService.disconnectWorker($scope.getLabel(master.location), $.param({\n            workerURL: worker.location,\n            masterLocation: getLocation(master)\n        })).success(function () {\n            $scope.deleteLink(d);\n\n            worker.cluster = worker.cluster.filter(function (x) {\n                return x !== master.cluster;\n            });\n\n            delete master.workers[worker.location];\n\n            onSuccess();\n\n            toastr.success(\"Disconnected worker from master.\", \"\");\n        }).error(function (data) {\n            toastr.error(getError(data), \"Error disconnecting worker\");\n        }).finally(function () {\n            $scope.setLoader(false);\n        });\n    }\n\n    function disconnectNodes(d, master, worker, onSuccess) {\n        ClusterRestService.disconnectNodes($scope.getLabel(master.location), $.param({\n            masterLocation: getLocation(master),\n            masterNodeID: master.nodeID,\n            peerLocation: getLocation(worker),\n            peerRepositoryID: $scope.getLabel(worker.location),\n            peerNodeID: worker.nodeID\n        })).success(function (data) {\n            $scope.deleteLink(d, true);\n\n            delete worker.peers[master.location];\n            delete master.peers[worker.location];\n\n            onSuccess();\n\n            toastr.success(data, \"\");\n        }).error(function (data) {\n            toastr.error(getError(data), \"Error disconnecting masters\");\n        }).finally(function () {\n            $scope.setLoader(false);\n        });\n    }\n\n    $scope.disconnectLink = function (d, onSuccess, overrideDisabled) {\n        let master = {};\n        let worker = {};\n        if (d.source.repositoryType === 'master') {\n            master = d.source;\n            worker = d.target;\n        } else if (d.target.repositoryType === 'master') {\n            master = d.target;\n            worker = d.source;\n        }\n\n        if (!overrideDisabled && ('disabledReason' in master || worker.repositoryType === 'master' && 'disabledReason' in worker)) {\n            ModalService.openSimpleModal({\n                title: 'Confirm disconnect',\n                message: 'One of the masters is currently unreachable and will be disconnected only at the reachable master.'\n                + '<br><br>Proceed only if you know what you are doing.',\n                warning: true\n            }).result\n                .then(function () {\n                    $scope.disconnectLink(d, onSuccess, true);\n                });\n\n            return;\n        }\n\n        $scope.setLoader(true, 'Disconnecting nodes...');\n\n        if (worker.repositoryType === 'worker') {\n            disconnectWorker(d, master, worker, onSuccess);\n        } else {\n            // Both are masters, despite the var name worker\n            disconnectNodes(d, master, worker, onSuccess);\n        }\n    };\n\n    // Called directives so we include scope apply here\n    $scope.selectNode = function (node) {\n        if ($scope.selectedNode !== node) {\n            $scope.selectedNode = node;\n        } else {\n            $scope.selectedNode = null;\n        }\n        $scope.$apply();\n    };\n\n    $scope.isWorker = function (node) {\n        return node !== undefined && node !== null && node.repositoryType === 'worker';\n    };\n\n    $scope.connectMasters = function (first, second, bidirectional, onSuccess) {\n        const firstConfigs = first.location.split('/repositories/');\n        const secondConfigs = second.location.split('/repositories/');\n\n        $scope.setLoader(true, 'Connecting nodes...');\n\n        ClusterRestService.connectNodes(firstConfigs[1], {\n            masterLocation: first.local ? 'local' : firstConfigs[0],\n            masterNodeID: first.nodeID,\n            peerLocation: second.local ? 'local' : secondConfigs[0],\n            peerRepositoryID: secondConfigs[1],\n            peerNodeID: second.nodeID,\n            bidirectional: bidirectional\n        }).success(function (data) {\n            // FIXME?? is there a proper connection between the masters. We don't know so we use 'ON'\n            const timestamp = Date.now();\n\n            $scope.addOrUpdateLink(first, second, 'ON', timestamp);\n            first.peers[second.location] = 1;\n\n            if (bidirectional) {\n                second.peers[first.location] = 1;\n                $scope.addOrUpdateLink(second, first, 'ON', timestamp);\n            }\n\n            onSuccess();\n\n            toastr.success(data, \"\");\n        }).error(function (data) {\n            toastr.error(getError(data), \"Error connecting masters\");\n        }).finally(function () {\n            $scope.setLoader(false);\n        });\n    };\n\n    $scope.addOrUpdateLink = function (source, target, status, timestamp) {\n        const key = source.location + '|' + target.location;\n        let link = $scope.linksHash[key];\n        const reverseKey = target.location + '|' + source.location;\n        const reverseLink = $scope.linksHash[reverseKey];\n        if (!link) {\n            // adding a new link\n            link = {};\n            $scope.linksHash[key] = link;\n            $scope.links.push(link);\n            link['source'] = source;\n            link['target'] = target;\n            $scope.needsToRestart = true;\n        } else {\n            // updating, check if status changed\n            // no-op at the moment\n        }\n        link['status'] = status;\n        link['timestamp'] = timestamp;\n\n        link['reversePeerMissing'] = source.repositoryType === 'master' && target.repositoryType === 'master' && !reverseLink;\n        if (reverseLink && reverseLink['reversePeerMissing']) {\n            reverseLink['reversePeerMissing'] = false;\n        }\n        $scope.linksHash[key] = link;\n\n        if ($scope.updateWarnings) { // function isn't defined before render() is called\n            $scope.updateWarnings();\n        }\n\n        return link;\n    };\n\n    $scope.deleteLink = function (link, deleteReverse) {\n        $scope.links.splice($scope.links.indexOf(link), 1);\n        const key = link.source.location + '|' + link.target.location;\n        delete $scope.linksHash[key];\n        if (link.source.disabledReason || link.target.disabledReason) {\n            // removing a link to a funky node triggers a refresh to get rid of that node\n            console.log(\"link to funky node removed, refresh\");\n            $scope.needsToRefresh = true;\n        }\n\n        if (deleteReverse) {\n            const reverseKey = link.target.location + '|' + link.source.location;\n            const reverseLink = $scope.linksHash[reverseKey];\n            if (reverseLink) {\n                $scope.deleteLink(reverseLink, false);\n            }\n        }\n    };\n\n    $scope.updateMasterNode = function (node, timestamp, isUpdate, isRandomLink) {\n        return ClusterRestService.getMaster(node.name, {\n            params: {\n                masterLocation: getLocation(node)\n            }\n        })\n            .error(function (data) {\n                const newDisabledReason = \"The location is unreachable.\";\n\n                if (node.disabledReason !== newDisabledReason) {\n                    // show toast only once per disabled reason\n                    toastr.error(getError(data), \"Error accessing master \" + node.name);\n\n                    node.disabledReason = newDisabledReason;\n\n                    // Disabled, we don't know these so reset them to sane empty defaults\n                    node.peers = {};\n                    node.workers = {};\n                    node.hasWorkers = false;\n                }\n\n                node.timestamp = timestamp;\n\n                return true;\n            })\n            .success(function (masterData) {\n                node.averageReadTime = masterData.averageReadTime;\n                node.completedReads = masterData.completedReads;\n                node.completedWrites = masterData.completedWrites;\n                node.failedReads = masterData.failedReads;\n                node.failedWrites = masterData.failedWrites;\n                node.pendingWrites = masterData.pendingWrites;\n                node.runningReads = masterData.runningReads;\n                node.runningWrites = masterData.runningWrites;\n                node.readonly = masterData.readonly;\n                node.mode = masterData.mode;\n                node.nodeID = masterData.nodeID;\n                node.peers = {};\n                node.workers = {};\n                node.timestamp = timestamp;\n                node.hasWorkers = masterData.workers.length > 0;\n\n                masterData.peers.forEach(function (peer) {\n                    node.peers[peer.location] = 1;\n                    if (!(peer.location in $scope.urlToNode)) {\n                        // either someone added a repository behind our back or it's a repository we don't have in our locations\n                        if (isUpdate) {\n                            console.log('master disappeared, refreshing');\n                            $scope.needsToRefresh = true;\n                        } else {\n                            // TODO: Test this properly. Nodes shouldn't get events, should look disabled properly\n                            $scope.urlToNode[peer.location] = {\n                                name: $scope.getLabel(peer.location),\n                                disabledReason: \"You are not connected to this master's location or the master was deleted\",\n                                location: peer.location,\n                                nodeID: peer.nodeID,\n                                repositoryType: 'master',\n                                artificiallyAdded: true\n                            };\n                        }\n                    }\n\n                    // FIXME?? is there a proper connection between the masters\n                    $scope.addOrUpdateLink(node, $scope.urlToNode[peer.location], 'ON', timestamp);\n                });\n\n                masterData.workers.forEach(function (worker) {\n                    node.workers[worker.location] = 1;\n                    let workerNode = {};\n                    if (worker.location in $scope.urlToNode) {\n                        workerNode = $scope.urlToNode[worker.location];\n                    } else {\n                        // either someone added a repository behind our back or it's a repository we don't have in our locations\n                        if (isUpdate) {\n                            console.log('worker disappeared, refreshing');\n                            $scope.needsToRefresh = true;\n                            return;\n                        } else {\n                            workerNode = $scope.urlToNode[worker.location] = {\n                                name: $scope.getLabel(worker.location),\n                                location: worker.location,\n                                repositoryType: 'worker',\n                                artificiallyAdded: true\n                            };\n                        }\n                    }\n\n                    workerNode.fingerprint = worker.fingerprint;\n                    workerNode.averageTaskTime = worker.averageTaskTime;\n                    workerNode.failedTasks = worker.failedTasks;\n                    workerNode.completedTasks = worker.completedTasks;\n                    workerNode.runningTasks = worker.runningTasks;\n                    workerNode.timestamp = timestamp;\n\n                    if (workerNode.artificiallyAdded) {\n                        workerNode.disabledReason = \"You are not connected to this worker's location.\";\n                        if (worker.lastError) {\n                            workerNode.disabledReason += '<br>' + worker.lastError;\n                        }\n                    } else if (worker.lastError) {\n                        workerNode.disabledReason = worker.lastError;\n                    } else {\n                        delete workerNode.disabledReason;\n                    }\n\n                    if (workerNode.disabledReason) {\n                        workerNode.disabledReason = $sce.trustAsHtml(workerNode.disabledReason);\n                    }\n\n                    workerNode.cluster = workerNode.cluster || [];\n                    if (workerNode.cluster.indexOf(node.cluster) === -1) {\n                        workerNode.cluster.push(node.cluster);\n                    }\n\n                    let status = worker.status;\n\n                    // debug stuff\n                    if (isRandomLink) {\n                        status = ['UNINITIALIZED', 'ON', 'OFF', 'REPLICATION_SERVER', 'REPLICATION_CLIENT',\n                            'OUT_OF_SYNC', 'OUT_OF_SYNC_FORCED', 'WAITING_WRITE', 'WRITING'][Math.floor(Math.random() * 9)]; // NOSONAR\n                    }\n                    // end of debug stuff\n\n                    $scope.addOrUpdateLink(node, $scope.urlToNode[worker.location], status, timestamp);\n                });\n            }).catch(function () {\n                return true;\n            });\n    };\n\n    $scope.getNodes = function () {\n        // Reset all of these, just in case\n        $scope.nodes = [];\n        $scope.links = [];\n        $scope.linksHash = {};\n        $scope.clone = {};\n        $scope.selectedNode = null;\n        $scope.clusters = [];\n\n        $scope.setLoader(true);\n\n        return RepositoriesRestService.getCluster()\n            .success(function (data) {\n                $scope.hasNodes = data.length > 0;\n                $scope.links = [];\n                $scope.linksHash = {};\n                $scope.clusters = [];\n\n                const timestamp = Date.now();\n\n                $scope.urlToNode = data.reduce(function (result, node) {\n                    if (node.type === \"master\" || node.type === \"worker\") {\n                        result[node.uri] = {\n                            name: $scope.getLabel(node.uri),\n                            local: node.local,\n                            location: node.uri,\n                            repositoryType: node.type,\n                            timestamp: timestamp\n                        };\n                    }\n                    return result;\n                }, {});\n\n                let clusterIdx = 0;\n\n                const mastersData = Object.keys($scope.urlToNode).filter(function (key) {\n                    return $scope.urlToNode[key].repositoryType === 'master';\n                }).sort(function (k1, k2) {\n                    if (k1 < k2) {\n                        return -1;\n                    } else if (k1 > k2) {\n                        return 1;\n                    }\n\n                    return 0;\n                }).map(function (key) {\n                    const node = $scope.urlToNode[key];\n\n                    node.cluster = clusterIdx;\n                    $scope.clusters.push(node);\n                    clusterIdx++;\n                    return $scope.updateMasterNode(node, timestamp);\n                });\n\n                return $q.all(mastersData).finally(function () {\n                    $scope.nodes = _.sortBy(\n                        Object.keys($scope.urlToNode).map(function (key) {\n                            return $scope.urlToNode[key];\n                        }),\n                        ['name']\n                    );\n\n                    $scope.render();\n\n                    $scope.setLoader(false);\n                });\n\n            })\n            .error(function (data) {\n                $scope.hasNodes = false;\n                toastr.error(getError(data), \"Error getting nodes\");\n                $scope.setLoader(false);\n            })\n            .finally(function () {\n                $scope.needsToRefresh = false;\n            });\n    };\n\n    $scope.trackAddedOrRemovedNodes = function (timestamp) {\n        return RepositoriesRestService.getCluster()\n            .success(function (data) {\n                const uri2tempNode = data.reduce(function (result, node) {\n                    if (node.type === \"master\" || node.type === \"worker\") {\n                        result[node.uri] = {\n                            location: node.uri,\n                            repositoryType: node.type\n                        };\n                    }\n                    return result;\n                }, {});\n\n                for (let i = 0; i < $scope.nodes.length; i++) {\n                    const node = $scope.nodes[i];\n                    if (node.location in uri2tempNode) {\n                        if (!node.artificiallyAdded) {\n                            // old node exists in new list, update timestamp and delete from new list\n                            node.timestamp = timestamp;\n                            delete uri2tempNode[node.location];\n                        }\n                    } else if (!node.artificiallyAdded) {\n                        // old node disappeared and it's not disabled, force refresh\n                        console.log(\"old node disappeared, refresh\");\n                        $scope.needsToRefresh = true;\n                        return true;\n                    }\n                }\n\n                if (Object.keys(uri2tempNode).length > 0) {\n                    // there are still nodes in the new list, which means someone added a repo, force refresh\n                    console.log(\"new nodes appeared, refresh\");\n                    $scope.needsToRefresh = true;\n                }\n            })\n            .error(function (data) {\n                toastr.error(getError(data), \"Error getting nodes\");\n            });\n    };\n\n    $scope.updateClusterIfNeeded = function (checkNodes) {\n        // raise flag to prevent calling this more than once before one invocation completes\n        $scope.updating = true;\n\n        const timestamp = Date.now();\n\n        const processUpdate = function () {\n            if (!$scope.needsToRefresh) {\n                // check for nodes disconnected behind our back, or nodes entirely removed\n                for (let i = 0; i < $scope.links.length; i++) {\n                    const link = $scope.links[i];\n                    if (link['timestamp'] !== timestamp) {\n                        console.log('nodes disconnected, removing link');\n                        // In reality if a user disconnects the bidirectional peer-to-peer link\n                        // between masters in only one direction we'd still have a single link\n                        // in the cluster manager. This is tricky and we can't do much about it for now.\n                        $scope.deleteLink(link, false);\n                    }\n                }\n            }\n\n            if ($scope.needsToRefresh) {\n                // major changes, we need to refresh\n                console.log('refresh requested');\n                $scope.getNodes();\n            } else if ($scope.needsToRestart) {\n                // only statuses changed, just restart the graph\n                console.log('only links changed, restarting');\n                $scope.restart();\n            } else {\n                // updates the statuses (colours of links)\n                $scope.updateStatuses();\n                // update colours for multimaster workers\n                $scope.updateColors();\n                // update warnings for missing bidi links\n                $scope.updateWarnings();\n                // updating done (when we refresh, restart() will do that instead)\n                $scope.updating = false;\n            }\n        };\n\n        if (checkNodes) {\n            $scope.trackAddedOrRemovedNodes(timestamp).then(function () {\n                if (!$scope.needsToRefresh) {\n                    const promises = [];\n                    for (let i = 0; i < $scope.nodes.length; i++) {\n                        const node = $scope.nodes[i];\n                        if (node.repositoryType === 'master') {\n                            promises.push($scope.updateMasterNode(node, timestamp, true));\n                        }\n                    }\n                    $q.all(promises).finally(processUpdate);\n                } else {\n                    processUpdate();\n                }\n            });\n        } else {\n            const promises = [];\n            for (let i = 0; i < $scope.nodes.length; i++) {\n                const node = $scope.nodes[i];\n                if (node.repositoryType === 'master') {\n                    promises.push($scope.updateMasterNode(node, timestamp, true));\n                }\n            }\n            $q.all(promises).finally(processUpdate);\n        }\n    };\n\n    $scope.getNodes();\n\n    $scope.setMode = function (mode) {\n        $scope.attributeChange = true;\n        $scope.setMasterAttribute($scope.selectedNode, 'Mode', mode);\n    };\n\n    $scope.setReadonly = function (readonly) {\n        $scope.attributeChange = true;\n        $scope.selectedNode.readonly = readonly;\n        $scope.setMasterAttribute($scope.selectedNode, 'ReadOnly', readonly);\n    };\n\n    let timerCounter = 0;\n    const timer = $interval(function () {\n        // check for update only if not in the middle of set attribute operation\n        if (!$scope.attributeChange && !$scope.updating) {\n            timerCounter++;\n            // every third iteration also checks for added/removed nodes\n            $scope.updateClusterIfNeeded(timerCounter % 3 === 0);\n        }\n    }, 2000);\n\n    $scope.$on(\"$destroy\", function () {\n        $interval.cancel(timer);\n    });\n\n    $scope.attributeChange = false;\n    $scope.updating = false;\n\n    // track window resizing\n    const w = angular.element($window);\n    const resize = function () {\n        $scope.resize();\n    };\n    w.bind('resize', resize);\n    $scope.$on('$destroy', function () {\n        w.unbind('resize', resize);\n    });\n\n    // track collapsing the nav bar\n    $scope.$on('onToggleNavWidth', function () {\n        $scope.resize();\n    });\n}\n\nCloneRepositoryCtrl.$inject = ['$scope', '$modalInstance', 'clone'];\n\nfunction CloneRepositoryCtrl($scope, $modalInstance, clone) {\n\n    $scope.clone = angular.copy(clone);\n    $scope.ok = function () {\n        const patt = new RegExp('^[a-zA-Z0-9-_]+$');\n        $scope.isInvalidRepoName = !patt.test($scope.clone.repositoryID);\n        if (!$scope.isInvalidRepoName) {\n            $modalInstance.close($scope.clone);\n        }\n    };\n\n    $scope.cancel = function () {\n        $modalInstance.dismiss('cancel');\n    };\n}\n"],"sourceRoot":""}